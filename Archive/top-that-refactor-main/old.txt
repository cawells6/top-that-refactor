This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
public/
  client.js
  index.html
  style.css
.gitignore
.replit
{}
cp.spawn('node'
game.js
index.js
package.json
restart-server.js
server.js
test-cpu-run.js
test-restart.js
wait.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# Replit debugger
.breakpoints
</file>

<file path="{}">
[33m[nodemon] 3.1.10[39m
[33m[nodemon] to restart at any time, enter `rs`[39m
[33m[nodemon] watching path(s): '*.js'[39m
[33m[nodemon] watching extensions: js,css,html[39m
[32m[nodemon] starting `npx kill-port 3000 && node -e "setTimeout(() =, 1000)" && node server.js`[39m
Process on port 3000 killed
[31m[nodemon] app crashed - waiting for file changes before starting...[39m
[32m[nodemon] restarting child process[39m
[32m[nodemon] starting `npx kill-port 3000 && node -e "setTimeout(() =, 1000)" && node server.js`[39m
Process on port 3000 killed
[31m[nodemon] app crashed - waiting for file changes before starting...[39m
</file>

<file path="cp.spawn('node'">
[33m[nodemon] 3.1.10[39m
[33m[nodemon] to restart at any time, enter `rs`[39m
[33m[nodemon] watching path(s): '*.js'[39m
[33m[nodemon] watching extensions: js,css,html[39m
[32m[nodemon] starting `npx kill-port 3000 && node -e "setTimeout(() =, ['server.js'], {stdio: 'inherit'})), 1000)"`[39m
Process on port 3000 killed
[31m[nodemon] app crashed - waiting for file changes before starting...[39m
</file>

<file path="test-cpu-run.js">
import { io } from 'socket.io-client';

// Test server URL can be overridden by CLI arg, CPU_TEST_URL env var, or npm --url
const CLI_URL = process.argv[2];
const NPM_URL = process.env.npm_config_url;
const URL = CLI_URL || process.env.CPU_TEST_URL || NPM_URL || 'http://localhost:3000';
console.log(`[CPU TEST] connecting to server URL: ${URL}`);

const TOTAL_PLAYERS = 4;
const BOT_COUNT = 3; // number of headless clients joining host

async function start() {
  await new Promise(res => setTimeout(res, 500)); // wait for server startup

  const host = io(URL, { extraHeaders: { referer: URL } });
  host.on('connect', () => {
    console.log('[HOST] connected, creating lobby');
    host.emit('join', 'Host', TOTAL_PLAYERS, 0, null); // human host, no auto CPUs
  });
  host.on('connect_error', err => console.error('[HOST CONNECT_ERROR]', err));
  host.on('err', e => console.error('[HOST ERROR]', e));
  host.on('lobby', ({ roomId, players }) => {
    console.log(`[HOST] lobby ${roomId} has ${players.length}/${TOTAL_PLAYERS} players`);
    // spawn bot clients until full
    for (let i = 1; i <= BOT_COUNT; i++) {
      const bot = io(URL, { extraHeaders: { referer: URL } });
      bot.on('connect_error', err => console.error(`[BOT${i} CONNECT_ERROR]`, err));
      bot.on('connect', () => {
        console.log(`[BOT${i}] connecting to lobby`);
        bot.emit('join', `Bot${i}`, TOTAL_PLAYERS, 0, roomId); // human-style join
      });
      bot.on('err', e => console.error(`[BOT${i} ERROR]`, e));
      bot.on('state', s => {
        if (s.started) console.log(`[BOT${i}] game started`);
      });
    }
    // start the game
    setTimeout(() => {
      console.log('[HOST] triggering startGame');
      host.emit('startGame');
    }, 500);
  });

  host.on('state', s => {
    if (s.started) console.log('[HOST] received started state');
  });
}

start();
</file>

<file path="test-restart.js">
// Test script to verify restart-server.js functionality
// This will create a server on port 3000, then try to run restart-server.js
// to verify it can properly handle and resolve port conflicts
import http from 'http';
import { spawn } from 'child_process';
const PORT = 3000;

console.log('=== TEST RESTART SERVER SCRIPT ===');
console.log(`1. Creating a dummy server on port ${PORT} to simulate occupation`);

// Create a server that will occupy port 3000
const server = http.createServer((req, res) => {
  res.writeHead(200);
  res.end('Test server running on port 3000');
});

let testResult = false;
let testTimeout = null;

// Start the test server
server.listen(PORT, () => {
  console.log(`Dummy server started on port ${PORT}`);
  
  // Give the server a moment to fully initialize
  setTimeout(() => {
    console.log(`2. Server running on port ${PORT}, now testing restart-server.js`);
    
    // Run our restart-server.js script
    const restartProcess = spawn('node', ['restart-server.js'], {
      stdio: 'inherit' // Show output in the console
    });
    
    // Set a timeout for the overall test
    testTimeout = setTimeout(() => {
      console.log('\nâŒ TEST FAILED: Timeout waiting for restart-server.js to complete');
      process.exit(1);
    }, 30000); // 30 second timeout
    
    // Check if a new server comes up after our script runs
    checkServerStatusPeriodically();
  }, 2000);
});

// Function to periodically check if a new server is up after our old one is killed
function checkServerStatusPeriodically() {
  let checkCount = 0;
  const maxChecks = 15;
  
  const checkInterval = setInterval(() => {
    checkCount++;
    
    // Make a request to see if a new server is running
    const req = http.request({
      hostname: 'localhost',
      port: PORT,
      path: '/',
      method: 'GET',
      timeout: 1000
    }, (res) => {
      // If we can connect successfully after our original server should have been killed,
      // it means the restart process worked
      if (checkCount > 5) { // Skip the first few checks when we expect our test server to still be alive
        console.log(`âœ… TEST PASSED: New server detected on port ${PORT} after restart`);
        testResult = true;
        cleanup();
      }
    });
    
    req.on('error', (err) => {
      if (err.code === 'ECONNREFUSED' && checkCount > 5) {
        // This is expected during the restart transition - the port should be briefly unavailable
        console.log(`Port ${PORT} unavailable (try ${checkCount}/${maxChecks}), waiting for new server...`);
      }
    });
    
    req.end();
    
    // End testing after maximum checks
    if (checkCount >= maxChecks) {
      console.log('âŒ TEST FAILED: New server did not come up after the expected time');
      cleanup();
    }
  }, 2000);
  
  function cleanup() {
    clearInterval(checkInterval);
    if (testTimeout) clearTimeout(testTimeout);
    setTimeout(() => {
      process.exit(testResult ? 0 : 1);
    }, 1000);
  }
}

process.on('SIGINT', () => {
  console.log('Test interrupted, cleaning up...');
  process.exit(1);
});
</file>

<file path="wait.js">
// wait.js - Helper to kill port 3000 and wait before server restart
import { exec } from 'child_process';

console.log('[wait] Killing any process on port 3000...');
exec('npx kill-port 3000', (err, stdout, stderr) => {
  if (err) {
    console.log(`[wait] Error killing port: ${err.message}`);
  } else {
    console.log(`[wait] Port kill result: ${stdout.trim() || 'No output'}`);
  }
  
  // Wait 1.5 seconds to ensure port is fully released
  console.log('[wait] Waiting 1.5s for port to be released...');
  setTimeout(() => {
    console.log('[wait] Done waiting, starting server...');
    process.exit(0); // Exit successfully so nodemon continues to the next command
  }, 1500);
});
</file>

<file path="index.js">
import express from "express";
import { Server } from "socket.io";
import http from "http";
import { Game } from "./game.js";

const app = express();
const server = http.createServer(app);
const io = new Server(server);

const game = new Game(io);

app.use(express.static("public"));
server.listen(3000, () => console.log("Server running on http://localhost:3000"));
</file>

<file path="restart-server.js">
// Trigger restart: May 2, 2025
import { exec, spawn } from 'child_process';

const PORT = 3000;
const MAX_RETRIES = 10;
const DELAY_AFTER_KILL = 3000; // Increased to 3 seconds
const RETRY_INTERVAL = 2000; // Add a consistent retry interval
const PORT_CHECK_TIMEOUT = 60000; // 60 seconds timeout for port checks
const isWin = process.platform === 'win32';
const listCmd = isWin ? `netstat -ano | findstr :${PORT}` : `lsof -i :${PORT}`;
const killCmdTemplate = isWin ? pid => `taskkill /PID ${pid} /F` : pid => `kill -9 ${pid}`;

console.log('Finding processes using port 3000...');

// Global flag to prevent multiple restarts running at once
let restartInProgress = false;

// Poll until port is free or timeout
function waitForPortFree(interval = 1000, timeout = PORT_CHECK_TIMEOUT) {
  return new Promise(resolve => {
    const startTime = Date.now();
    function check() {
      exec(listCmd, (err, stdout) => {
        console.log(`[waitForPortFree] listCmd output (err: ${err ? err.code : 'none'}):\n${stdout}`);
        const lines = stdout.trim().split('\n');
        
        // If error with code 1 or no output lines, port is free
        if ((err && err.code === 1) || !stdout || stdout.trim() === '' || lines.length <= 1) {
          console.log(`[waitForPortFree] Port ${PORT} is free after ${(Date.now() - startTime) / 1000}s`);
          return resolve(true);
        }
        
        // Check if we've timed out
        if (Date.now() - startTime > timeout) {
          console.warn(`[waitForPortFree] Timeout waiting for port ${PORT} to free after ${(Date.now() - startTime) / 1000}s.`);
          return resolve(false);
        }
        
        console.log(`[waitForPortFree] Port ${PORT} still in use, checking again in ${interval}ms...`);
        setTimeout(check, interval);
      });
    }
    check();
  });
}

// Function to try to find and kill any processes using our port
async function killProcessesOnPort() {
  return new Promise((resolve) => {
    exec(listCmd, async (error, stdout, stderr) => {
      console.log(`[killProcessesOnPort] listCmd output (err: ${error ? error.code : 'none'}):\n${stdout}`);

      // Handle case where no processes are found
      if (error && error.code === 1) {
        console.log(`No process found using port ${PORT}`);
        return resolve(true);
      }
      
      if (error) {
        console.error(`[killProcessesOnPort] Error finding process: ${error.message}`);
        return resolve(false);
      }
      
      const lines = stdout.trim().split('\n');
      console.log(`[killProcessesOnPort] listCmd lines:`, lines);
      
      if (!stdout || stdout.trim() === '' || lines.length <= 1) {
        console.log(`No process found using port ${PORT}`);
        return resolve(true);
      }
      
      // Parse the output to find the PID(s)
      const pids = [];
      if (isWin) {
        for (let i = 0; i < lines.length; i++) {
          const cols = lines[i].trim().split(/\s+/);
          if (cols.length > 4) {
            const pid = cols[cols.length - 1];
            if (pid && /^\d+$/.test(pid)) {
              pids.push(pid);
            }
          }
        }
      } else {
        for (let i = 0; i < lines.length; i++) {
          const match = lines[i].match(/\s+(\d+)\s+/);
          if (match && match[1]) {
            pids.push(match[1]);
          }
        }
      }
      
      console.log(`[killProcessesOnPort] Parsed PIDs:`, pids);
      
      if (pids.length === 0) {
        console.log(`No PIDs found for port ${PORT}`);
        return resolve(true);
      }
      
      console.log(`Found processes with PIDs: ${pids.join(', ')}`);
      
      // Kill the processes
      const uniquePids = [...new Set(pids)]; // Remove duplicates
      const killPromises = uniquePids.map(pid => new Promise(killResolve => {
        const killCmd = killCmdTemplate(pid);
        console.log(`Killing process ${pid} using: ${killCmd}`);
        exec(killCmd, (killError, killStdout, killStderr) => {
          if (killError) {
            console.error(`Error killing process ${pid}: ${killError.message}`);
          } else {
            console.log(`Process ${pid} terminated successfully. kill stdout: ${killStdout}, kill stderr: ${killStderr}`);
          }
          killResolve();
        });
      }));
      
      await Promise.all(killPromises);
      console.log('All processes killed, waiting for port to free...');
      resolve(true);
    });
  });
}

// Main restart function
async function restartServer() {
  // Prevent multiple concurrent restarts
  if (restartInProgress) {
    console.log('[restartServer] Restart already in progress, skipping duplicate trigger.');
    return;
  }
  
  restartInProgress = true;
  console.log('[restartServer] Starting server restart process...');
  
  try {
    // First attempt to kill processes on the port
    await killProcessesOnPort();
    
    // Wait for kill commands to take effect
    console.log(`[restartServer] Waiting ${DELAY_AFTER_KILL}ms for kill commands to take effect...`);
    await new Promise(resolve => setTimeout(resolve, DELAY_AFTER_KILL));
    
    // Check if port is really free
    const portIsFree = await waitForPortFree(1000, PORT_CHECK_TIMEOUT);
    
    if (portIsFree) {
      console.log('[restartServer] Port is confirmed free, starting new server...');
      await startNewServer();
    } else {
      console.error('[restartServer] Port is still in use after timeout. Force killing and trying one more time...');
      // Try one more aggressive kill attempt
      await killProcessesOnPort();
      await new Promise(resolve => setTimeout(resolve, DELAY_AFTER_KILL * 1.5));
      await startNewServer();
    }
  } catch (err) {
    console.error('[restartServer] Error during restart:', err);
  } finally {
    restartInProgress = false;
    console.log('[restartServer] Restart process completed.');
  }
}

// Improved server start function
async function startNewServer(retryCount = 0) {
  return new Promise(resolve => {
    if (retryCount >= MAX_RETRIES) {
      console.error(`[startNewServer] Max retries (${MAX_RETRIES}) reached. Giving up.`);
      return resolve(false);
    }
    
    console.log(`[startNewServer] Attempt ${retryCount + 1}: Starting new server...`);
    
    // Use spawn with ES module syntax
    const server = spawn('node', ['server.js'], {
      stdio: 'inherit', // This will pipe the output directly to the parent process
      detached: true,   // This allows the child to run independently of the parent
      shell: true       // Run command inside a shell
    });
    
    server.on('error', (error) => {
      console.error(`[startNewServer] Failed to start server: ${error.message}`);
      
      if (error.message.includes('EADDRINUSE')) {
        console.warn(`[startNewServer] Port ${PORT} still in use, retrying in ${RETRY_INTERVAL/1000}s...`);
        setTimeout(() => startNewServer(retryCount + 1).then(resolve), RETRY_INTERVAL);
      } else {
        resolve(false);
      }
    });
    
    server.on('close', (code) => {
      if (code !== 0) {
        console.error(`[startNewServer] Server process exited with code ${code}`);
        setTimeout(() => startNewServer(retryCount + 1).then(resolve), RETRY_INTERVAL);
      } else {
        console.log('[startNewServer] Server started successfully.');
        resolve(true);
      }
    });
    
    // Unref so the parent process can exit independently of the child
    if (server.unref) {
      server.unref();
    }
    
    // If we get here without an immediate error, assume success for now
    setTimeout(() => {
      console.log('[startNewServer] Server appears to be starting up...');
      resolve(true);
    }, 1000);
  });
}

// Start the restart process
restartServer().catch(err => {
  console.error('[Main] Uncaught error during restart:', err);
});
</file>

<file path=".replit">
entrypoint = "server.js"
modules = ["nodejs-22"]
hidden = [".config", "package-lock.json"]

[gitHubImport]
requiredFiles = [".replit", "replit.nix", "package.json", "package-lock.json"]

[nix]
channel = "stable-24_11"

[deployment]
run = ["npm", "run", "dev"]
deploymentTarget = "autoscale"
ignorePorts = false

[workflows]
runButton = "Start Server"

[[workflows.workflow]]
name = "Start Server"
author = 35830124
mode = "sequential"

[[workflows.workflow.tasks]]
task = "shell.exec"
args = "npm run dev"

[[ports]]
localPort = 3000
externalPort = 80
</file>

<file path="package.json">
{
  "name": "threes-card-game",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon --watch '*.js' --ignore 'public/*.js' --ignore 'test-*.js' --ext js,css,html --delay 2.5 --exec \"node wait.js && node server.js\"",
    "test:cpu": "node test-cpu-run.js"
  },
  "dependencies": {
    "express": "^4.21.2",
    "nodejs": "^0.0.0",
    "socket.io": "^4.7.2",
    "socket.io-client": "^4.7.2"
  },
  "devDependencies": {
    "nodemon": "^3.1.10",
    "kill-port": "^1.6.1"
  }
}
</file>

<file path="server.js">
import express from 'express';
import { createServer as createHttpServer } from 'http';
import { Server } from 'socket.io';
import path from 'path';
import { fileURLToPath } from 'url';
import { Game } from './game.js';
import fs from 'fs'; // add at top

console.log("File saved!"); // Fixed typo in debug message
console.log("[Test Restart] Server started at: " + new Date().toISOString());
console.log("[Restart Test] File change detected at: 2025-04-24");

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function createServer() {
  const app = express();
  const httpServer = createHttpServer(app);
  const io = new Server(httpServer);

  // Store active games
  const games = new Map(); // Maps roomId -> Game instance
  const socketToRoom = new Map(); // Maps socket.id -> roomId

  // Add no-cache headers to prevent browser caching
  app.use((req, res, next) => {
    res.set('Cache-Control', 'no-store, no-cache, must-revalidate, private');
    next();
  });

  app.use(express.static(path.join(__dirname, 'public'), { etag: false, maxAge: 0 }));

  // Admin endpoint to stop all games
  app.post('/admin/stopAllGames', (req, res) => {
    console.log('ðŸ›‘ Admin requested stopAllGames. Clearing all rooms.');
    games.forEach((game, roomId) => {
      // notify players
      io.to(roomId).emit('notice', 'Server is stopping all games.');
      // reset and delete game
      game.reset();
      games.delete(roomId);
    });
    return res.send('All games stopped');
  });

  io.on('connection', socket => {
    console.log(`ðŸ§© Socket connected: ${socket.id}`);

    // Helper to emit lobby updates for a specific room
    const updateLobby = (roomId) => {
      if (games.has(roomId)) {
        const game = games.get(roomId);
        const lobbyData = game.players.map(p => ({ id: p.id, name: p.name }));
        // Emit to the specific room
        io.to(roomId).emit('lobby', { 
          players: lobbyData, 
          maxPlayers: game.MAX_PLAYERS, 
          roomId: roomId 
        });
      }
    };

    socket.on('join', (name, totalPlayers, numComputers, roomParam) => {
      try {
        // Normalize inputs
        const requestedTotal = Math.min(Math.max(parseInt(totalPlayers, 10) || 2, 2), 4);
        const cpuCount = Math.min(Math.max(parseInt(numComputers, 10) || 0, 0), requestedTotal - 1);
        const withComputer = cpuCount > 0;
        // Use roomParam to target existing room if provided
        let targetRoomId = roomParam || null;

        // Unified lobby creation/join logic for humans and computers
        // Attempt to join existing room if roomParam provided and valid
        let game = null;
        if (targetRoomId && games.has(targetRoomId)) {
          const existing = games.get(targetRoomId);
          if (!existing.started && existing.players.length < existing.MAX_PLAYERS) {
            game = existing;
          } else {
            targetRoomId = null;
          }
        }
        // Fallback: if no URL room specified and exactly one open room exists, join it
        if (!game) {
          const open = Array.from(games.entries())
            .filter(([, g]) => !g.started && g.players.length < g.MAX_PLAYERS);
          if (open.length === 1) {
            const [id, existing] = open[0];
            game = existing;
            targetRoomId = id;
          }
        }
        // Create new room if no valid existing
        if (!game) {
          const newRoomId = Math.random().toString(36).substring(2, 8);
          game = new Game(io);
          game.roomId = newRoomId;  // Associate roomId with game instance
          // limit players to requested total
          game.MAX_PLAYERS = requestedTotal;
          games.set(newRoomId, game);
          targetRoomId = newRoomId;
        }
        // Join socket to room
        socket.join(targetRoomId);
        socketToRoom.set(socket.id, targetRoomId);
        // Add the human player
        if (!game.addPlayer(socket, name)) {
          socket.emit('err', 'Failed to join game: Room may be full or started.');
          return;
        }
        socket.emit('gameRoom', targetRoomId);
        console.log(`Player ${name} joined room ${targetRoomId}`);
        // Add computer players if requested
        if (withComputer) {
          console.log(`Adding ${cpuCount} computer players to room ${targetRoomId}`);
          for (let i = 0; i < cpuCount; i++) game.addComputerPlayer();
        }
        // Update lobby view
        updateLobby(targetRoomId);
        // Await client 'startGame' action to begin game
        return;
      } catch (err) {
        console.error('âŒ Join error:', err.message, err.stack);
        socket.emit('err', err.message);
      }
    });

    // Add listener for manual start request
    socket.on('startGame', () => {
      const roomId = socketToRoom.get(socket.id);
      if (!roomId || !games.has(roomId)) return;
      const game = games.get(roomId);
      if (!game.started && game.players.length >= 2) {
        console.log(`Game start triggered by player in room ${roomId}`);
        game.startGame();
      }
    });

    socket.on('playCards', idxs => {
      const roomId = socketToRoom.get(socket.id);
      try {
        if (!roomId || !games.has(roomId)) return;
        games.get(roomId).play(socket, idxs);
      } catch (err) {
        console.error('âŒ Play error:', err.message, err.stack);
        socket.emit('err', err.message);
      }
    });

    socket.on('takePile', () => {
      const roomId = socketToRoom.get(socket.id);
      try {
        if (!roomId || !games.has(roomId)) return;
        const game = games.get(roomId);
        game.takePile(socket);

        // Computer turn logic is now handled within game.js after state push
      } catch (err) {
        console.error('âŒ TakePile error:', err.message, err.stack);
        socket.emit('err', err.message);
      }
    });

    // Add chat message handler
    socket.on('chatMessage', (message) => {
      const roomId = socketToRoom.get(socket.id);
      if (!roomId || !games.has(roomId)) return;
      const game = games.get(roomId);
      const player = game.byId(socket.id);
      if (player && !player.isComputer) { // Only allow human players to chat
        // Broadcast message to the room, including sender
        io.to(roomId).emit('chatMessage', { 
          sender: player.name, 
          message: message 
        });
      }
    });

    socket.on('rejoin', (playerId, roomId) => {
      console.log(`ðŸ”„ Player ${playerId} attempting to rejoin room ${roomId}`);
      if (games.has(roomId)) {
        const game = games.get(roomId);
        const player = game.findPlayerById(playerId); // Use the new method

        if (player && player.disconnected) {
          console.log(`âœ… Reconnecting player ${player.name} (${playerId}) to room ${roomId}`);
          player.sock = socket; // Re-assign the new socket
          player.disconnected = false;
          socket.join(roomId);
          socketToRoom.set(socket.id, roomId);
          socket.emit('joined', { id: player.id }); // Confirm rejoin
          socket.emit('gameRoom', roomId); // Send room ID back
          game.pushState(); // Send current game state
          updateLobby(roomId); // Update lobby if game hasn't started
        } else if (player && !player.disconnected) {
          console.warn(`âš ï¸ Player ${playerId} tried to rejoin room ${roomId} but was already connected.`);
          // Maybe force disconnect old socket? For now, just log.
          socket.emit('err', 'Already connected in another session.');
        } else {
          console.warn(`ðŸš« Player ${playerId} failed to rejoin room ${roomId}: Player not found or game state issue.`);
          socket.emit('err', 'Could not rejoin the game. Please join again.');
        }
      } else {
        console.warn(`ðŸš« Player ${playerId} failed to rejoin room ${roomId}: Room not found.`);
        socket.emit('err', 'Game room no longer exists. Please join again.');
      }
    });

    socket.on('disconnect', () => {
      const roomId = socketToRoom.get(socket.id);
      const playerId = socket.id; // Use socket.id as the player ID before it's gone
      console.log(`ðŸ”Œ Socket disconnected: ${playerId} from room ${roomId}`);
      try {
        if (roomId && games.has(roomId)) {
          const game = games.get(roomId);
          // Mark player as disconnected instead of removing
          game.markPlayerDisconnected(playerId);
          socketToRoom.delete(playerId); // Clean up map using the correct ID

          // Check if all players are disconnected
          const activePlayers = game.players.filter(p => !p.disconnected);
          if (activePlayers.length === 0) {
            console.log(`ðŸ—‘ï¸ All players disconnected from room ${roomId}. Deleting game.`);
            games.delete(roomId);
          } else if (!game.started) {
            // If game not started, update lobby for remaining players
            updateLobby(roomId);
          } else {
            // If game started, push state to show player disconnected
            game.pushState();
          }
        }
      } catch (err) {
        console.error('âŒ Disconnect error:', err.message, err.stack);
      }
    });

    socket.on('adminReset', () => {
      const roomId = socketToRoom.get(socket.id);
      if (!roomId || !games.has(roomId)) return;
      console.log(`ðŸ›‘ Game reset via Ctrl+R in room ${roomId}`);
      const game = games.get(roomId);
      io.to(roomId).emit('notice', 'Game resetting...');

      // Get all socket IDs in the room before disconnecting
      const socketsInRoom = io.sockets.adapter.rooms.get(roomId);
      if (socketsInRoom) {
        socketsInRoom.forEach(socketId => {
          const sock = io.sockets.sockets.get(socketId);
          if (sock) {
            sock.disconnect(true);
          }
          socketToRoom.delete(socketId); // Clean up map for each disconnected socket
        });
      }

      // Reset game state and delete game instance
      game.reset();
      games.delete(roomId);
      console.log(`ðŸ—‘ï¸ Game room ${roomId} deleted after reset.`);
    });
  }); // End of io.on('connection')

  // Watch public assets and broadcast reload to clients
  const publicPath = path.join(__dirname, 'public');
  fs.watch(publicPath, { recursive: true }, (eventType, filename) => {
    console.log(`ðŸ”„ Public file changed (${filename}), sending reload to clients.`);
    io.emit('reload');
  });

  return httpServer;
}

const server = createServer();
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`Top That! server listening on :${PORT}`);
});

// Graceful shutdown for SIGTERM/SIGINT
process.on('SIGTERM', () => {
  console.log('SIGTERM received. Shutting down gracefully...');
  server.close(() => {
    console.log('Server closed successfully.');
    process.exit(0);
  });
  setTimeout(() => {
    console.log('Forced shutdown after timeout');
    process.exit(1);
  }, 5000);
});

process.on('SIGINT', () => {
  console.log('SIGINT received. Shutting down gracefully...');
  server.close(() => {
    console.log('Server closed successfully.');
    process.exit(0);
  });
  setTimeout(() => {
    console.log('Forced shutdown after timeout');
    process.exit(1);
  }, 5000);
});
</file>

<file path="public/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TopÂ That! â€“ Card Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="style.css" />
  <script defer src="/socket.io/socket.io.js"></script>
  <script defer type="module" src="client.js"></script>
</head>
<body>
  <header id="main-header">
    <div class="header-content">
      <div class="brand">
        <h1 class="logo"><span class="logo-icon">ðŸ‘‘</span> TopÂ That!</h1>
        <p class="tagline">OneÂ Pile.Â OneÂ Winner.Â NoÂ Mercy.</p>
      </div>
      <nav>
        <button id="rules-button" class="btn btn-secondary" aria-haspopup="dialog">HowÂ toÂ Play</button>
        <button id="back-to-lobby-button" class="btn btn-secondary">Lobby</button>
        <!-- Rewind/Forward controls -->
        <button id="rewind-btn" class="btn btn-secondary hidden">â—€ Prev</button>
        <button id="forward-btn" class="btn btn-secondary hidden">Next â–¶</button>
      </nav>
    </div>
  </header>

  <div id="notice-banner" class="notice hidden"></div>
  <div id="error-banner" class="notice hidden"></div>
  <div id="modal-overlay" class="hidden"></div>

  <main id="main-content">
    <div id="lobby-container" class="hidden">
      <div id="lobby-form-card">
        <h2 id="lobby-heading">Join a Game</h2>
        <div id="lobby-form-content">
          <div class="form-group">
            <label for="name">Your Name</label>
            <input type="text" id="name" placeholder="Enter your name" aria-required="true" />
            <div id="name-error" class="error-message hidden">Please enter your name.</div>
          </div>
          <!-- Unified game setup: total players and CPU count -->
          <div class="form-group">
            <label for="total-players">Total Players <small>(max 4)</small></label>
            <input type="number" id="total-players" min="2" max="4" value="2" />
          </div>
          <div class="form-group">
            <label for="computer-count">Computer Opponents</label>
            <input type="number" id="computer-count" min="0" max="3" value="0" />
          </div>
          <div class="form-group button-group">
            <button id="create-join" class="btn btn-primary">Create / Join Game</button>
          </div>
        </div>
        <div id="waiting-state" class="hidden">
          <h3 id="waiting-heading">Waiting for players...</h3>
          <div class="spinner">
            <div class="dot1"></div>
            <div class="dot2"></div>
          </div>
          <p id="share-link-message">Share the link to invite others!</p>
          <button id="copy-link-button" class="btn btn-tertiary">Copy Invite Link</button>
          <button id="start-game-button" class="btn btn-primary hidden">Start Game</button>
        </div>
      </div>
    </div>

    <div id="table" class="hidden">
      <div class="table-board">
        <div class="table-slot-top"></div>
        <div class="table-slot-left"></div>
        <div class="table-slot-center">
          <div id="center" class="center-area">
            <!-- createCenterPiles() will insert deck and discard piles here -->
            <!-- special effects are now overlaid on cards; errors shown as toast -->
          </div>
        </div>
        <div class="table-slot-right"></div>
        <div class="table-slot-bottom"></div>
      </div>
    </div>
  </main>
  <section id="game-log" class="game-log hidden">
    <h3>Game Log</h3>
    <div id="game-log-entries" style="max-height:200px; overflow-y:auto; background:#f9f9f9; padding:10px; border:1px solid #ccc;"></div>
  </section>

  <div id="rules-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="rules-modal-title">
    <div class="modal-content">
      <h2 id="rules-modal-title">How to Play Top That!</h2>
      <button class="modal-close-button" aria-label="Close rules">&times;</button>
      <ul>
        <li>Game Setup
          <ul class="sublist">
            <li>- Use 1 deck for 1â€“3 players; 2 decks for 4â€“8 players.</li>
            <li>- Deal each player, in order:
              <ul style="margin-left: 2em;">
                <li>3 cards face-down</li>
                <li>3 cards face-up</li>
                <li>3 cards in their hand</li>
              </ul>
            </li>
            <li>- Place the rest face-down as the draw pile.</li>
            <li>- Turn the top card face-up to start the discard pile.</li>
          </ul>
        </li>
        <li>On Your Turn
          <ul class="sublist">
            <li>- Play one or more hand cards higher than the top discard.</li>
            <li>- After playing, draw back up to 3 cards (if the draw pile isnâ€™t empty).</li>
            <li>- If you canâ€™t play, pick up the entire discard pile into your hand.</li>
            <li>- End by passing play to the next player.</li>
          </ul>
        </li>
        <li>Special Cards
          <ul class="sublist">
            <li>- 2: Reset the pile. Next player may play any card.</li>
            <li>- 5: Copy the last cardâ€™s value. If itâ€™s the first in a new pile, treat as normal.</li>
            <li>- 10: Clear the discard pileâ€”those cards are removed.</li>
            <li>- Four-of-a-kind: Also clears the pile, regardless of value.</li>
          </ul>
        </li>
        <li>Playing Up & Down Cards
          <ul class="sublist">
            <li>- Finish hand cards before playing face-up.</li>
            <li>- Finish face-up before playing face-down.</li>
            <li>- Only one face-up or face-down card may be played per turn, even if you have multiples of the same value.</li>
            <li>- If you canâ€™t play an up/down card, pick up the discard pile and resume with hand cards.</li>
          </ul>
        </li>
        <li>Winning
          <ul class="sublist">
            <li>- First to empty hand, face-up, and face-down cards wins.</li>
          </ul>
        </li>
      </ul>
    </div>
  </div> <!-- end rules-modal -->
  <!-- Toast container for error messages -->
  <div id="toast-container"></div>
</body>
</html>
</file>

<file path="game.js">
export class Game {
  // Standardized delays (in milliseconds)
  static DELAY_INITIAL_PLACEMENT = 1000;    // delay before first card placement
  static DELAY_SPECIAL_DISPLAY = 1500;      // duration to show special banners (reduced from 2000ms)
  static DELAY_AFTER_PLAY = 300;            // pause after any card is placed before next turn
  static DELAY_FIRST_TURN = 1000;           // delay before starting first turn
  static DELAY_CPU_DECISION = 720;          // time for CPU to "think" before playing

  constructor(io) {
    this.io = io;
    this.roomId = null;  // Associate roomId set by server for logging
    this.MAX_PLAYERS = 4; // Max players (can be adjusted)
    this.CPU_MOVE_DELAY = Game.DELAY_CPU_DECISION;  // CPU reaction delay after special banners
    this.reset();
  }

  // Helper methods for consistent card value checks
  isSpecialCard(value) {
    return this.isWildCard(value) || this.isTenCard(value);
  }

  isWildCard(value) {
    return this.isTwoCard(value) || this.isFiveCard(value);
  }

  isTwoCard(value) {
    return value == 2; // Use loose equality for consistent type checking
  }

  isFiveCard(value) {
    return value == 5;
  }

  isTenCard(value) {
    return value == 10;
  }

  checkWinCondition(player) {
    // Player wins if they have no hand, no up cards, and no down cards
    if (!player) return false;
    return player.hand.length === 0 && player.up.length === 0 && player.down.length === 0;
  }

  addPlayer(sock, name = 'Player') {
    if (this.started) {
      sock.emit('err', 'Game already started');
      return false;
    }
    if (this.players.length >= this.MAX_PLAYERS) {
      sock.emit('err', 'Game room is full');
      return false;
    }

    this.players.push({ id: sock.id, sock, name, hand: [], up: [], down: [], disconnected: false }); // Initialize disconnected
    sock.emit('joined', { id: sock.id });

    return true;
  }

  addComputerPlayer() {
    if (this.started) {
      console.warn('Attempted to add computer player after game started.');
      return false;
    }
    if (this.players.length >= this.MAX_PLAYERS) {
      console.warn('Attempted to add computer player to a full game.');
      return false;
    }

    const computerCount = this.players.filter(p => p.isComputer).length;
    const computerId = `computer_${computerCount + 1}`;
    const computerName = `CPU ${computerCount + 1}`;

    console.log(`Adding computer player: ${computerName} (${computerId})`);
    this.players.push({
      id: computerId,
      name: computerName,
      isComputer: true,
      hand: [],
      up: [],
      down: [],
      disconnected: false // Initialize disconnected
    });

    return true;
  }

  markPlayerDisconnected(playerId) {
    const player = this.players.find(p => p.id === playerId);
    if (player) {
      console.log(`Marking player ${player.name} (${player.id}) as disconnected.`);
      player.disconnected = true;
      player.sock = null; // Remove socket reference
    }
  }

  findPlayerById(playerId) {
    return this.players.find(p => p.id === playerId);
  }

  play(sock, idxs) {
    const p = this.findPlayerById(sock.id);
    console.log(`[SERVER] play() called by ${p ? p.name : 'unknown'} (${sock.id}) with idxs: ${JSON.stringify(idxs)}. Current turn: ${this.turn}`);
    if (!p || p.disconnected || (this.turn !== p.id)) { // Simplified turn check
        return;
    }

    // Determine if player is playing down cards
    const isPlayingDownCards = idxs.some(i => i >= 2000);
    
    const cards = idxs.map(i => {
      if (i === 2000) return p.down[0];
      if (i >= 1000) return p.up[i - 1000];
      return p.hand[i];
    });
    if (!cards.every(c => c)) {
        sock.emit?.('err', 'Invalid card selection');
        return;
    }

    if (!this.valid(cards)) {
        console.log(`[DEBUG play] Invalid play attempted by ${p.name} (${sock.id}) with cards: ${JSON.stringify(cards)}. Current turn: ${this.turn}`);
        
        // Handle invalid plays differently based on card type
        if (isPlayingDownCards) {
            // For down cards: take the pile (player can't see them)
            cards.forEach(c => p.hand.push(c));
            this.sortHand(p);
            this.io.to(this.roomId).emit('specialEffect', { value: null, type: 'invalid' });
            this.takePile(sock);
            // Emit log event for invalid play
            this.io.to(this.roomId).emit('log', { player: p.name, action: 'invalid', cards });
        } else {
            // For hand or up cards: show error message but DON'T take pile
            // Return cards to player's hand if they were from hand
            if (!idxs.some(i => i >= 1000)) {
                cards.forEach(c => p.hand.push(c));
                this.sortHand(p);
            }
            // Send error to player
            sock.emit?.('err', 'Invalid play: card must be higher than the top card');
            // Emit log event for invalid attempt
            this.io.to(this.roomId).emit('log', { player: p.name, action: 'invalid-attempt', cards });
        }
        return;
    }
    
    // Rest of the function handles valid plays
    // Emit log event for successful play
    this.io.to(this.roomId).emit('log', { player: p.name, action: 'play', cards });

    // Card removal logging
    const handBefore = [...p.hand];
    const upBefore = [...p.up];
    const downBefore = [...p.down];
    p.hand = p.hand.filter((_, i) => !idxs.includes(i));
    if (idxs.some(i => i >= 1000 && i < 2000)) {
      p.up = p.up.filter((_, i) => !idxs.includes(i + 1000));
    }
    if (idxs.some(i => i >= 2000)) {
      p.down.shift();
    }
    console.log(`[SERVER] After card removal: hand: ${JSON.stringify(handBefore)} -> ${JSON.stringify(p.hand)}, up: ${JSON.stringify(upBefore)} -> ${JSON.stringify(p.up)}, down: ${JSON.stringify(downBefore)} -> ${JSON.stringify(p.down)}`);

    cards.forEach(c => this.playPile.push(c));
    console.log(`[DEBUG play] ${p ? p.name : 'unknown'} played cards: ${JSON.stringify(cards)}. New playPile: ${JSON.stringify(this.playPile)}. Turn: ${this.turn}`);
    const playedValue = cards[0].value;
    const isFourOfAKind = cards.length === 4;

    // Update lastRealCard (using helper methods for consistency)
    if (!this.isSpecialCard(playedValue) && !isFourOfAKind) {
        this.lastRealCard = cards[0];
    }

    const finishTurn = () => {
        // Check for win condition FIRST
        if (this.checkWinCondition(p)) {
          console.log(`[SERVER] Player ${p.name} wins!`);
          this.io.to(this.roomId).emit('gameOver', { winnerId: p.id, winnerName: p.name });
          this.started = false;
          return;
        }
        // Advance turn and push state BEFORE refill
        this.advanceTurn();
        console.log(`[SERVER] finishTurn: Advancing turn. New turn: ${this.turn}`);
        this.pushState();
        this.refill(p);
        if (this.checkWinCondition(p)) {
          console.log(`[SERVER] Player ${p.name} wins after refill!`);
          this.io.to(this.roomId).emit('gameOver', { winnerId: p.id, winnerName: p.name });
          this.started = false;
          return;
        }
        const nextPlayer = this.byId(this.turn);
        if (nextPlayer && nextPlayer.isComputer) {
          console.log(`[SERVER] finishTurn: Scheduling CPU turn (${nextPlayer.id}) with delay: ${Game.DELAY_CPU_DECISION}ms`);
          setTimeout(() => this.computerTurn(nextPlayer.id), Game.DELAY_CPU_DECISION);
        }
    };

    // For all played cards (special or regular), emit the effect and add animation delay
    // Special cards (2, 5, 10) or four-of-a-kind get their specific animation
    if (this.isTenCard(playedValue) || isFourOfAKind) {
        // Show special effect banner
        this.io.emit('specialEffect', { value: 10, type: isFourOfAKind ? 'four' : 'ten' });
        // Do not mutate the play pile or push state until after the animation delay
        setTimeout(() => {
            // Burn effect: move play pile to discard, draw new card if available
            this.discard = (this.discard || []).concat(this.playPile.splice(0));
            if (this.deck.length > 0) {
                const nextCard = this.draw();
                this.playPile.push(nextCard);
                if (!this.isSpecialCard(nextCard.value)) {
                    this.lastRealCard = nextCard;
                } else {
                    this.lastRealCard = null;
                }
            } else {
                this.lastRealCard = null;
            }
            finishTurn();
        }, Game.DELAY_SPECIAL_DISPLAY);
        return;
    } else if (this.isFiveCard(playedValue)) {
        this.io.emit('specialEffect', { value: 5, type: 'five' });
        setTimeout(() => {
            if (this.lastRealCard) this.playPile.push({ ...this.lastRealCard, copied: true });
            finishTurn();
        }, Game.DELAY_SPECIAL_DISPLAY);
        return;
    } else if (this.isTwoCard(playedValue)) {
        this.io.emit('specialEffect', { value: 2, type: 'two' });
        setTimeout(finishTurn, Game.DELAY_SPECIAL_DISPLAY);
        return;
    }
    // For regular cards (A, K, etc.), show a brief play animation too
    this.io.emit('specialEffect', { value: playedValue, type: 'regular' });
    // Standard delay after regular card play - increase from 300ms to allow animation to be seen
    setTimeout(finishTurn, Game.DELAY_AFTER_PLAY + 1000);
  }

  computerTurn(computerId = 'computer') {
    const computer = this.findPlayerById(computerId);
    console.log(`[DEBUG computerTurn] Called for ${computerId}. Current turn: ${this.turn}`);
    if (!computer || computer.disconnected || this.turn !== computer.id) return;

    setTimeout(() => {
      const t = this.effectiveTop();
      if (computer.hand.length > 0) {
        const wilds = computer.hand
          .map((card, index) => ({ card, index }))
          .filter(({ card }) => this.isSpecialCard(card.value));
        const regulars = computer.hand
          .map((card, index) => ({ card, index }))
          .filter(({ card }) => !this.isSpecialCard(card.value));
        const playableRegulars = regulars.filter(({ card }) => this.valid([card]));
        const playableWilds = wilds.filter(({ card }) => this.valid([card]));
        let playChoice = null;
        if (playableRegulars.length > 0 && playableWilds.length > 0 && Math.random() < 0.2) {
          playChoice = playableWilds[Math.floor(Math.random() * playableWilds.length)];
        } else if (playableRegulars.length > 0) {
          if (playableRegulars.length > 1 && Math.random() < 0.2) {
            playChoice = playableRegulars[playableRegulars.length - 1];
          } else {
            playChoice = playableRegulars[0];
          }
        } else if (playableWilds.length > 0) {
          const ten = playableWilds.find(({ card }) => this.isTenCard(card.value));
          if (ten) playChoice = ten;
          else playChoice = playableWilds[0];
        }
        if (playChoice) {
          this.play({ id: computerId }, [playChoice.index]);
          return;
        }
      }
      if (computer.hand.length === 0 && computer.up.length > 0) {
        const playableUpCards = computer.up
          .map((card, index) => ({ card, index }))
          .filter(({ card }) => this.valid([card]));
        if (playableUpCards.length > 0) {
          let playIdx = 0;
          if (playableUpCards.length > 1 && Math.random() < 0.2) {
            playIdx = playableUpCards.length - 1;
          }
          this.play({ id: computerId }, [playableUpCards[playIdx].index + 1000]);
          return;
        }
      }
      if (computer.hand.length === 0 && computer.up.length === 0 && computer.down.length > 0) {
        this.play({ id: computerId }, [2000]);
        return;
      }
      // No moves: take the pile then schedule next CPU turn if any
      this.takePile({ id: computerId, skipNotice: true });
      // After auto-pickup, schedule the next CPU turn
      setTimeout(() => this.computerTurn(this.turn), Game.DELAY_CPU_DECISION);
      return;
    }, Game.DELAY_CPU_DECISION);
  }

  takePile(sock) {
    const p = this.findPlayerById(sock.id);
    console.log(`[DEBUG takePile] called by ${sock.id}, turn before givePile: ${this.turn}`);

    // Always emit specialEffect for take pile and wait for animation before updating state
    this.io.emit('specialEffect', { value: null, type: 'take' });
    
    // Wait a moment for the animation to play before actually giving the pile
    setTimeout(() => {
      this.givePile(p, 'You picked up the pile');
      console.log(`[DEBUG takePile] turn after givePile: ${this.turn}`);
      
      // Notify players of the take-pile event
      if (p.sock && !p.isComputer) {
        this.players.forEach(other => {
          if (other.id !== p.id && other.sock) {
            other.sock.emit('opponentTookPile', { playerId: p.id });
          }
        });
      } else if (p.isComputer && !sock.skipNotice) {
        this.players.forEach(other => {
          if (other.sock && !other.isComputer) {
            other.sock.emit('notice', `${p.name} must take the pile.`);
          }
        });
      }
      
      // Finally, push the updated game state
      this.pushState();
      // If next player is a computer, schedule their turn with the proper delay
      const nextPlayer = this.byId(this.turn);
      if (nextPlayer && nextPlayer.isComputer) {
        setTimeout(() => this.computerTurn(nextPlayer.id), Game.DELAY_CPU_DECISION);
      }
    }, Game.DELAY_SPECIAL_DISPLAY); // Use the same delay as other special effects
  }

  startGame() {
    if (this.started) {
      console.warn("startGame called but game already started.");
      return;
    }
    if (this.players.length < 2) {
        console.warn(`startGame called but only ${this.players.length} players present.`);
        return;
    }
    console.log(`Starting game setup for players: ${this.players.map(p => p.name).join(', ')}`);

    // --- Initial Setup (No Card Yet) ---
    this.started = true;
    this.buildDeck();
    this.deal();
    this.turn = null; // No turn yet
    this.playPile = []; // Ensure play pile is empty initially
    this.lastRealCard = null;
    this.pushState(); // Push state with hands dealt, empty pile
    console.log(`Initial empty state pushed. Waiting ${Game.DELAY_INITIAL_PLACEMENT}ms before placing first card.`);

    // --- Wait before placing the first card ---
    setTimeout(() => {
      if (!this.started) return; // Check if game was reset during delay
      console.log(`Placing initial card...`);
      let initialCard = null;
      while (this.deck.length > 0) {
        initialCard = this.draw();
        // If it's a 10, burn then continue drawing
        if (this.isTenCard(initialCard.value)) {
          this.playPile.push(initialCard);
          this.lastRealCard = null;
          this.pushState();
          this.io.emit('specialEffect', { value: 10, type: 'ten' });
          setTimeout(() => {
            this.discard = (this.discard || []).concat(this.playPile.splice(0));
            // draw next non-10 if available
            let nextCard = null;
            while (this.deck.length > 0) {
              nextCard = this.draw();
              if (!this.isTenCard(nextCard.value)) break;
              this.discard = (this.discard || []).concat(nextCard);
              this.io.emit('specialEffect', { value: 10, type: 'ten' });
              nextCard = null;
            }
            if (nextCard) {
              this.playPile.push(nextCard);
              if (!this.isSpecialCard(nextCard.value)) {
                this.lastRealCard = nextCard;
              } else {
                this.lastRealCard = null;
              }
              this.pushState();
            }
            // Schedule first turn after special display
            setTimeout(() => {
              if (!this.started || !this.players.length) return;
              this.turn = this.players[0].id;
              this.pushState();
              const firstPlayer = this.byId(this.turn);
              if (firstPlayer && firstPlayer.isComputer) {
                this.computerTurn(firstPlayer.id);
              }
            }, Game.DELAY_FIRST_TURN);
          }, Game.DELAY_SPECIAL_DISPLAY);
          return;
        }
        break; // non-10, place normally
      }
      if (initialCard) {
        this.playPile.push(initialCard); // Place the card
        if (!this.isSpecialCard(initialCard.value)) {
          this.lastRealCard = initialCard;
        }
        this.pushState();
      } else {
        this.lastRealCard = null;
      }
      // Wait before starting the first turn
      setTimeout(() => {
        if (!this.started || !this.players.length) return;
        this.turn = this.players[0].id;
        this.pushState();
        const firstPlayer = this.byId(this.turn);
        if (firstPlayer && firstPlayer.isComputer) {
          this.computerTurn(firstPlayer.id);
        }
      }, Game.DELAY_FIRST_TURN);
    }, Game.DELAY_INITIAL_PLACEMENT);
  }

  buildDeck() {
    const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
    const vals = [2, 3, 4, 5, 6, 7, 8, 9, 10, 'J', 'Q', 'K', 'A'];
    this.deck = [];
    
    // Add the first standard deck
    suits.forEach(s => vals.forEach(v => this.deck.push({ value: v, suit: s })));
    
    // Add a second deck ONLY if we have 4+ players
    if (this.players.length >= 4) {
      suits.forEach(s => vals.forEach(v => this.deck.push({ value: v, suit: s })));
    }
    
    console.log(`Built deck with ${this.deck.length} cards for ${this.players.length} players (${this.players.length >= 4 ? '2 decks' : '1 deck'})`);
    this.shuffle(this.deck);
  }

  deal() {
    for (let i = 0; i < 3; i++) {
      this.players.forEach(p => {
        p.down.push(this.draw());
      });
    }
    for (let i = 0; i < 3; i++) {
      this.players.forEach(p => {
        p.up.push(this.draw());
      });
    }
    for (let i = 0; i < 3; i++) {
      this.players.forEach(p => {
        p.hand.push(this.draw());
      });
    }
    this.players.forEach(p => {
      this.sortHand(p);
      if (p.isComputer) {
        console.log('ðŸ¤– Computer player cards:', {
          hand: p.hand.length,
          up: p.up.length,
          down: p.down.length
        });
      }
    });
  }

  draw() {
    return this.deck.pop();
  }

  shuffle(a) {
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
  }

  top() {
    return this.playPile.at(-1);
  }

  effectiveTop() {
    const t = this.top();
    if (!t) return null;
    if (this.isFiveCard(t.value) && t.copied && this.lastRealCard) {
      return { ...this.lastRealCard, copied: true };
    }
    return t;
  }

  byId(id) {
    return this.players.find(p => p.id === id && !p.disconnected);
  }

  rank(c) {
    const v = String(c.value).toUpperCase();
    if (this.isTwoCard(c.value)) return 2;
    return { 'J': 11, 'Q': 12, 'K': 13, 'A': 14 }[v] ?? parseInt(v);
  }

  valid(cards) {
    if (cards.length === 4) {
      console.log(`[DEBUG valid] Checking four cards: ${JSON.stringify(cards.map(c => c.value))}. Should return true.`);
      return true;
    }

    if (!cards.length || !cards.every(c => c.value === cards[0].value)) return false;
    if (this.isSpecialCard(cards[0].value)) return true;
    const t = this.effectiveTop();
    if (!t) return true;
    const isValidRank = this.rank(cards[0]) > this.rank(t);
    if (!isValidRank) {
        console.log(`[DEBUG valid] Rank check failed: Card ${cards[0].value} (rank ${this.rank(cards[0])}) vs Pile ${t.value} (rank ${this.rank(t)})`);
    }
    return isValidRank;
  }

  refill(p) {
    while (p.hand.length < 3 && this.deck.length) {
      p.hand.push(this.draw());
    }
    this.sortHand(p);
  }

  sortHand(p) {
    p.hand.sort((a, b) => this.rank(a) - this.rank(b));
  }
  
  hasMove(p) {
    if (p.hand.length > 0) {
      if (p.hand.some(c => this.valid([c]))) {
        return true;
      }
    }

    if (p.up.length > 0) {
      if (p.up.some(c => this.valid([c]))) {
        return true;
      }
    }

    if (p.down.length > 0) {
      return true;
    }

    return false;
  }

  givePile(p, msg) {
    const pile = this.playPile.splice(0).map(c => {
      const copy = { ...c };
      delete copy.copied;
      return copy;
    });
    p.hand.push(...pile);
    this.sortHand(p);
    if (this.deck.length) this.playPile.push(this.draw());
    if (p.sock) {
      p.sock.emit('notice', msg);
      p.sock.emit('notice', '');
    }
    this.advanceTurn();
  }

  pushState() {
    const currentPlayer = this.byId(this.turn);

    // Remove forced 'must take the pile' notice logic
    // Only auto-pickup for CPU when no moves
    if (currentPlayer && !this.hasMove(currentPlayer)) {
      if (currentPlayer.isComputer) {
        setTimeout(() => this.takePile({ id: currentPlayer.id, skipNotice: true }), 97);
        return; // Skip further state push until after pickup
      }
      // For humans, do not emit any notice or block the UI; let them take the pile at any time
    } else if (currentPlayer && currentPlayer.sock) {
      currentPlayer.sock.emit('notice', '');
    }

    console.log(`[SERVER] pushState: turn=${this.turn}, playPile=${JSON.stringify(this.playPile)}, players=${this.players.map(p=>p.id+':'+p.hand.length).join(',')}`);

    this.players.forEach(targetPlayer => {
      if (targetPlayer.sock && !targetPlayer.disconnected) {
        targetPlayer.sock.emit('state', {
          deckCount: this.deck.length,
          playPile: this.playPile,
          discardCount: (this.discard || []).length,
          turn: this.turn,
          players: this.players.map(p => ({
            id: p.id,
            name: p.name,
            isComputer: p.isComputer,
            disconnected: p.disconnected,
            hand: p.id === targetPlayer.id ? p.hand : [],
            handCount: p.hand.length,
            up: p.up,
            down: p.id === targetPlayer.id ? p.down : p.down.map(() => ({ back: true })),
            downCount: p.down.length
          })),
          started: this.started
        });
      }
    });
  }

  advanceTurn() {
    if (!this.started || this.players.length < 2) return;
    const currentPlayerIndex = this.players.findIndex(player => player.id === this.turn);
    if (currentPlayerIndex === -1) {
      this.turn = this.players.find(p => !p.disconnected)?.id || null;
      console.log(`[SERVER] advanceTurn: Current player not found, setting turn to ${this.turn}`);
      return;
    }
    let nextPlayerIndex = (currentPlayerIndex + 1) % this.players.length;
    let attempts = 0;
    while (this.players[nextPlayerIndex].disconnected && attempts < this.players.length) {
      nextPlayerIndex = (nextPlayerIndex + 1) % this.players.length;
      attempts++;
    }
    if (attempts >= this.players.length) {
      console.warn("[SERVER] advanceTurn: All players seem disconnected. Setting turn to null.");
      this.turn = null;
    } else {
      this.turn = this.players[nextPlayerIndex].id;
      console.log(`[SERVER] advanceTurn: Turn advanced to ${this.players[nextPlayerIndex].name} (${this.turn})`);
    }
  }

  reset() {
    this.players = [];
    this.deck = [];
    this.playPile = [];
    this.discard = [];
    this.turn = null;
    this.started = false;
    this.lastRealCard = null;
  }
}
</file>

<file path="public/style.css">
/* ========== Color Variables & Root Styles ========== */
:root {
  --bg: #0b5137; /* Changed to dark green #0b5137 */
  --header-bg: #1b2e3c; /* Deep blue for header - REVERTED to #1b2e3c */
  --accent: #FFC300; /* Changed to bright gold */
  --accent2: #4a90e2; /* Muted Blue */
  --name: #FFC300; /* Changed to bright gold */
  --text: #f5f5f5;
  --mute: #b0bec5; /* Lighter Muted Gray */
  --panelBorder: #ffffff22;
  --active-border: #00CCCC; /* Changed to brighter teal (#00CCCC) */

  /* New colors */
  --card-bg: #ffffff;
  --card-text: #333333;
  --input-border: #cfd8dc; /* Light Gray */
  --placeholder-text: #78909c; /* Darkened for AA contrast */
  --error-color: #e53935; /* Red for validation */
  --btn-primary-bg: var(--accent);
  --btn-primary-text: #000000;
  --btn-secondary-bg: var(--accent); /* Changed to match the gold color */
  --btn-secondary-text: #ffffff;
  --btn-tertiary-bg: #78909c; /* Gray for Copy Link */
  --btn-tertiary-text: #ffffff;
  --body-bg-start: #367347; /* Changed gradient start to match main bg */
  --body-bg-mid: #2e5e3c;  /* Slightly darker for middle */
  --body-bg-end: #264c32;   /* Even darker for end */
  --overlay-bg: rgba(0, 0, 0, 0.6); /* Overlay background */

  /* Spacing */
  --header-height: 70px; /* Approximate height */
  --gutter: 24px;

  /* match your existing card dimensions */
  --card-w: 67.2px; /* 96px * 0.7 */
  --card-h: 92.4px; /* 132px * 0.7 */
  --card-peek: calc(var(--card-h) * 0.2);

  /* Z-index layers for predictable stacking */
  --z-base: 1;          /* Base layer for regular elements */
  --z-card: 10;         /* Regular cards */
  --z-card-hover: 20;   /* Cards being hovered */
  --z-card-selected: 30;/* Selected cards */
  --z-card-icon: 100;   /* Special card icons */
  --z-ui-elements: 200; /* Buttons and UI controls */
  --z-tutorial: 500;    /* Tutorial overlays */
  --z-modal: 1000;      /* Modal dialogs */
  --z-toast: 2000;      /* Toast messages */
  --z-game-over: 3000;  /* Game over overlay */
}

/* ========== Base Styles ========== */
* { box-sizing: border-box; margin: 0; padding: 0; }
html, body {
  height: 100%;
  font-family: sans-serif; /* Changed from 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif to clean sans-serif */
  color: var(--text);
}
body {
  /* Solid background instead of animated gradient */
  background: var(--bg);
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  /* Add padding-top to prevent content from hiding behind fixed header */
  padding-top: var(--header-height); 
  margin: 0;
  overflow-y: auto; /* Allow scrolling if content overflows */
}

/* Gradient Animation */
@keyframes gradientBG {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

/* Add this near the top of your CSS file, with the other animations */
@keyframes iconPulse {
  0% {
    transform: translate(-50%, -50%) scale(0.7);
    opacity: 0;
  }
  20% {
    transform: translate(-50%, -50%) scale(1.2);
    opacity: 1;
  }
  40% {
    transform: translate(-50%, -50%) scale(0.95);
    opacity: 1;
  }
  60% {
    transform: translate(-50%, -50%) scale(1.1);
    opacity: 1;
  }
  80% {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(-50%, -50%) scale(1);
    opacity: 0.9;
  }
}

/* Make the ring-pulse animation lighter for better performance */
@keyframes ring-pulse {
  0% { box-shadow: 0 0 0 0 rgba(255,255,255, 0.3); }
  70% { box-shadow: 0 0 0 12px rgba(255,255,255, 0); }
  100% { box-shadow: 0 0 0 0 rgba(255,255,255, 0); }
}

/* Card snap animation - make it smoother */
@keyframes snap-anim {
  0% { transform: translateY(0); }
  30% { transform: translateY(-12px); }
  100% { transform: translateY(0); }
}

/* Special card animation for highlighting special cards */
@keyframes specialCardPulse {
  0% {
    box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.8);
    transform: scale(1);
  }
  25% {
    box-shadow: 0 0 0 10px rgba(255, 255, 255, 0.4);
    transform: scale(1.05);
  }
  50% {
    box-shadow: 0 0 0 15px rgba(255, 255, 255, 0.2);
    transform: scale(1.08);
  }
  75% {
    box-shadow: 0 0 0 10px rgba(255, 255, 255, 0.1);
    transform: scale(1.05);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);
    transform: scale(1);
  }
}

/* Regular card glow animation */
@keyframes regularCardGlow {
  0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4); }
  50% { box-shadow: 0 0 15px 5px rgba(255, 255, 255, 0.6); }
  100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4); }
}

.special-card-pulse {
  animation: specialCardPulse 0.8s ease-in-out;
  z-index: 50;
  position: relative;
}

.regular-card-glow {
  animation: regularCardGlow 1.5s ease-in-out;
  z-index: 50;
  position: relative;
}

/* Add explicit card image sizing (fix monstrous card issue) */
.card-img {
  width: var(--card-w);
  height: var(--card-h);
  object-fit: contain;
  border-radius: 5px;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

/* ========== Header & Navigation ========== */
#main-header { /* Changed from header to #main-header */
  position: fixed; /* Fixed position */
  top: 0;
  left: 0;
  width: 100%;
  background: var(--header-bg);
  border-bottom: 2px solid var(--panelBorder);
  z-index: 1000; /* Ensure header stays on top */
  padding: 0; /* Remove padding, handle inside .header-content */
  height: var(--header-height);
  display: flex; /* Use flex to center content */
  align-items: center; /* Vertically center */
  justify-content: center; /* Horizontally center */
}

.header-content {
  display: flex;
  justify-content: space-between; /* Space out brand and nav */
  align-items: center;
  width: 100%;
  max-width: 1200px; /* Max width for content */
  padding: 0 1.5rem; /* Horizontal padding */
  gap: 1rem;
}

.brand {
  display: flex;
  flex-direction: column;
  margin-right: auto; /* Pushes nav to the right */
}
.logo {
  font-weight: 700;
  font-size: 2rem; /* Keep size */
  background: linear-gradient(90deg, var(--accent), var(--name));
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  display: flex; /* Align icon */
  align-items: center;
  gap: 0.5rem; /* Space between icon and text */
}
.logo-icon {
  font-size: 1.5rem; /* Adjust icon size */
  background: none; /* Remove gradient from icon */
  color: var(--accent); /* Use accent color for icon */
}

.tagline {
  font-size: 16px; /* Increased size */
  font-weight: 600;
  color: var(--name);
}

/* ========== Header & Navigation tweaks for nav buttons ========= */
#main-header nav {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}
#main-header nav .btn {
  width: auto;
}

/* Rules widget */
#rules summary {
  list-style: none;
  cursor: pointer;
  font-weight: 600;
  font-size: 1rem;
  color: var(--text); /* Ensure text is visible */
  padding: 0.5rem;
  border-radius: 4px;
  transition: background-color 0.2s;
}
#rules summary:hover {
  background-color: rgba(255, 255, 255, 0.1);
}
#rules summary::after { /* Underline on hover */
  content: '';
  display: block;
  width: 0;
  height: 2px;
  background: var(--accent);
  transition: width .3s;
  margin-top: 2px;
}
#rules summary:hover::after {
  width: 100%;
}

#rules-button {
  background: #FFC300; /* Match the rules modal border color */
  color: #000000; /* Black text for better contrast with gold */
  transition: background-color 0.2s;
}

#rules-button:hover {
  background: #ffd54f; /* Slightly lighter gold for hover effect */
}

/* Back to Lobby button styling */
#back-to-lobby-button {
  background: #FFC300; /* Match primary accent */
  color: #000000;
  margin-left: 0.5rem; /* Space from How to Play */
  transition: background-color 0.2s;
}
#back-to-lobby-button:hover {
  background: #ffd54f;
}

/* ========== Main Content & Lobby ========== */
#main-content { /* Changed from main to #main-content */
  flex: 1; /* Allow main to grow and fill space */
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center; /* Center lobby card vertically */
  width: 100%;
  padding: 1rem; /* Padding around content */
  position: relative; /* Needed for overlay positioning context */
  z-index: 1; /* Below header and modals */
}

#lobby-container {
  position: fixed; /* Fixed position to overlay content */
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1010; /* Above overlay, below header */
  pointer-events: none; /* Allow clicks through container itself */
  opacity: 0; /* Start hidden for fade-in */
  transition: opacity 0.3s ease-out;
}
#lobby-container:not(.hidden) {
  opacity: 1;
  pointer-events: auto; /* Enable interaction when visible */
}

#lobby-form-card {
  background: var(--card-bg);
  color: var(--card-text);
  border-radius: 12px; /* Slightly larger radius */
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2); /* Enhanced shadow */
  padding: var(--gutter) calc(var(--gutter) * 1.2); /* Adjust padding */
  width: 100%;
  max-width: 420px; /* Slightly wider */
  text-align: center;
  transform: scale(0.95); /* Start slightly smaller for transition */
  opacity: 0;
  transition: transform 0.3s ease-out, opacity 0.3s ease-out;
  pointer-events: auto; /* Ensure card itself is interactive */
}
#lobby-container:not(.hidden) #lobby-form-card {
  transform: scale(1); /* Scale up to normal size */
  opacity: 1;
}

#lobby-heading {
  font-size: 28px; /* Increased size */
  margin-bottom: var(--gutter);
  color: var(--card-text);
}

#lobby-form-content {
  display: flex;
  flex-direction: column;
  gap: calc(var(--gutter) * 0.75); /* Consistent spacing */
}

.form-group {
  text-align: left; /* Align labels/inputs left */
}

.form-group label {
  display: block;
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  color: var(--mute); /* Muted color for label */
  margin-bottom: 6px; /* Space between label and input */
}

.form-group input[type="text"],
.form-group input[type="number"] {
  width: 100%;
  padding: 10px 12px;
  border: 2px solid var(--input-border);
  border-radius: 8px;
  font-size: 16px;
  color: var(--card-text);
  background-color: #fff; /* Ensure background is white */
  transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out; /* Add box-shadow transition */
}

.form-group input[type="text"]::placeholder,
.form-group input[type="number"]::placeholder {
  color: var(--placeholder-text);
  font-size: 14px;
}

.form-group input[type="text"]:focus,
.form-group input[type="number"]:focus {
  outline: none;
  border-color: var(--accent); /* Accent color on focus */
  box-shadow: 0 0 0 3px rgba(255, 183, 77, 0.3); /* Accent glow */
}

/* Input validation error style */
.form-group input.input-error {
  border-color: var(--error-color);
}
.error-message {
  color: var(--error-color);
  font-size: 12px;
  margin-top: 4px;
}

.button-group {
  display: flex;
  gap: 1rem; /* Space between buttons */
  margin-top: calc(var(--gutter) * 0.5);
}

.computer-options {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-top: calc(var(--gutter) * 0.5);
}
.computer-options label {
  margin-bottom: 0; /* Remove bottom margin for inline label */
  flex-shrink: 0; /* Prevent label from shrinking */
}
.computer-options input[type="number"] {
  width: 60px; /* Smaller width for number input */
  text-align: center;
  padding: 8px; /* Adjust padding */
}

/* Polished Buttons */
.btn {
  padding: 10px 16px;
  border: none;
  border-radius: 8px; /* Match input radius */
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: transform 0.1s ease-out, box-shadow 0.1s ease-out, background-color 0.15s;
  width: 100%; /* Make buttons fill container in group */
  text-align: center;
}

.btn-primary {
  background-color: var(--btn-primary-bg);
  color: var(--btn-primary-text);
}

.btn-secondary {
  background-color: var(--btn-secondary-bg);
  color: var(--btn-secondary-text);
}

.btn-tertiary {
  background-color: var(--btn-tertiary-bg);
  color: var(--btn-tertiary-text);
  font-size: 14px; /* Smaller font for copy button */
  padding: 8px 12px;
}

.btn:hover:not(:disabled) {
  transform: translateY(-2px); /* Slight lift */
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.18); /* Slightly stronger shadow on hover */
}
.btn:active:not(:disabled) {
  transform: translateY(0);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

/* ========== Waiting State ========== */
#waiting-state {
  margin-top: var(--gutter);
  border-top: 1px solid var(--input-border);
  padding-top: var(--gutter);
}

#waiting-heading {
  font-size: 20px; /* Slightly smaller than main heading */
  margin-bottom: calc(var(--gutter) * 0.75);
  color: var(--card-text);
}

#share-link-message {
  font-size: 14px;
  color: var(--mute);
  margin-bottom: 1rem;
}

/* Spinner Animation */
.spinner {
  margin: 0 auto calc(var(--gutter) * 0.75) auto;
  width: 70px;
  text-align: center;
}

.spinner > div {
  width: 12px;
  height: 12px;
  background-color: var(--accent2); /* Use secondary color */
  border-radius: 100%;
  display: inline-block;
  animation: sk-bouncedelay 1.4s infinite ease-in-out both;
}

.spinner .dot1 {
  animation-delay: -0.32s;
}

.spinner .dot2 {
  animation-delay: -0.16s;
}

@keyframes sk-bouncedelay {
  0%, 80%, 100% { transform: scale(0); }
  40% { transform: scale(1.0); }
}

/* ========== Modals (Rules) ========== */
#modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: var(--overlay-bg);
  z-index: 999; /* Updated z-index */
  opacity: 0; /* Hidden by default */
  transition: opacity 0.3s ease-out;
  pointer-events: none; /* Allow clicks through when hidden */
}
#modal-overlay:not(.hidden) {
  opacity: 1;
  pointer-events: auto; /* Block clicks when visible */
}

.modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0.95); /* Start smaller/centered */
  background-color: var(--card-bg);
  color: var(--card-text);
  border-radius: 12px;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
  z-index: 1000; /* Updated z-index */
  width: 90%;
  max-width: 600px;
  max-height: 80vh; /* Limit height and allow scrolling */
  overflow-y: auto;
  opacity: 0;
  transition: transform 0.3s ease-out, opacity 0.3s ease-out;
  pointer-events: none; /* Hidden by default */
}
.modal:not(.hidden) {
  opacity: 1;
  transform: translate(-50%, -50%) scale(1); /* Animate to full size */
  pointer-events: auto; /* Enable interaction when visible */
}

.modal-content {
  padding: calc(var(--gutter) * 1.5); /* More padding */
  position: relative;
}

.modal-close-button {
  position: absolute;
  top: 12px;
  right: 16px;
  background: none;
  border: none;
  font-size: 2rem;
  line-height: 1;
  color: var(--mute);
  cursor: pointer;
  padding: 0.25rem;
}
.modal-close-button:hover {
  color: var(--card-text);
}

/* Rules modal specific styles */
#rules-modal {
  background-color: #0c3d2a; /* Darker version of our background for better contrast */
  color: #f5f5f5; /* Light text for readability */
  border: 2px solid #FFC300; /* Gold border to match our accent color */
}

#rules-modal-title {
  color: #FFC300; /* Gold color for title */
  font-size: 1.8rem;
  margin-bottom: 1.5rem;
  border-bottom: 1px solid rgba(255, 195, 0, 0.3);
  padding-bottom: 0.5rem;
}

#rules-modal .modal-content {
  padding: 1.5rem;
}

#rules-modal .modal-close-button {
  color: #FFC300; /* Gold color for close button */
  font-size: 2.2rem;
}

#rules-modal .modal-close-button:hover {
  color: white;
}

#rules-modal > .modal-content > ul > li { 
  margin-top: 1.2rem;
  font-weight: 600;
  color: #FFC300; /* Gold color for section headers */
  font-size: 1.2rem;
}

#rules-modal .sublist {
  margin-top: 0.5rem;
  margin-left: 1.4rem;
  font-weight: 400;
  color: #ffffff; /* White text for better readability */
  font-size: 1.15rem; /* Increased from 1.05rem */
  list-style-type: none; /* Remove default bullets */
  padding-left: 0.5rem;
}

#rules-modal .sublist li {
  margin-bottom: 0.6rem;
  line-height: 1.4; /* Better line spacing */
}

#rules-modal .sublist li::before {
  content: none;
}

/* ========== Notifications & Banners ========== */
.banner {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  padding: 0.5rem 1rem;
  background: var(--accent2);
  color: #fff;
  font-size: 1rem;
  font-weight: bold;
  text-align: center;
  border-radius: 0;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  z-index: 100; /* Updated z-index */
}

.error-banner {
  margin: 0; /* Remove any default margin */
  padding: 0.7rem 1.5rem;
  background: linear-gradient(90deg, #2e5e3c 80%, #367347 100%);
  color: #fffbe7;
  border: 2.5px solid #FFC300;
  border-radius: 10px;
  font-size: 1.18rem;
  font-weight: 700;
  text-align: center;
  box-shadow: 0 4px 18px 0 #0005, 0 0 0 2px #FFC30055;
  z-index: 200; /* Ensure it's above piles but below modals */
  min-width: 220px;
  max-width: 420px;
  letter-spacing: 0.5px;
  position: relative; /* Position relative to normal flow within #center */
  order: 3; /* Ensure it comes AFTER the piles wrapper (order 2) */
  margin-top: 0.8rem; /* Add margin above it (was 0.5rem) */
  width: 100%; /* Allow it to take full width for centering */
  box-sizing: border-box; /* Include padding in width calculation */
}

#error-banner.hidden {
  display: none !important;
}

.hidden { display: none !important; }

.took-pile-banner {
  background: #ffd36b;
  color: #222;
  font-weight: bold;
  font-size: 1.05rem;
  border-radius: 8px;
  padding: 0.3rem 1.1rem;
  margin-top: 0.5rem; /* Add margin above it */
  text-align: center;
  box-shadow: 0 2px 8px #0002;
  position: relative; /* Keep relative positioning */
  z-index: 30;
  animation: tookPileFadeIn 0.2s, tookPileFadeOut 0.4s 1.6s forwards;
}
@keyframes tookPileFadeIn {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}
@keyframes tookPileFadeOut {
  to { opacity: 0; transform: translateY(-10px); }
}

/* ========== Layout & Structure ========== */
#center {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  position: relative;
}

.center-area {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  position: relative;
  min-height: 200px;
  padding: 20px;
}

.center-piles-wrapper {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 1.5rem; /* closer piles */
  position: relative;
}

.center-pile-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.pile-label {
  font-size: 1rem;
  font-weight: 600;
  margin-bottom: 0.7rem;
  color: var(--text);
  text-align: center;
  text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
}

.pile {
  width: var(--card-w);
  height: var(--card-h);
  border-radius: 5px;
  background-color: rgba(255, 255, 255, 0.1);
  display: flex;
  justify-content: center;
  align-items: center;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(255, 255, 255, 0.1);
  z-index: 1; /* Updated z-index */
}

.deck, .discard {
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  z-index: 1; /* Updated z-index */
}

.deck:hover, .discard:hover {
  transform: translateY(-5px);
  box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4);
}

/* Align special and error banners directly above the piles */
.center-piles-wrapper {
  position: relative;
}
#event-banner,
#error-banner {
  position: absolute !important;
  bottom: calc(100% + 4px) !important;
  top: auto !important;
  left: 50% !important;
  transform: translateX(-50%) !important;
  margin-bottom: 0 !important;
  z-index: 120 !important;
}

/* Position banners in center area */
#event-banner,
#error-banner {
  top: -40px !important;
  bottom: auto !important;
  font-size: 1rem; /* consistent size */
}

.center-piles-wrapper {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 1.5rem;
}

.center-pile-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.pile-label {
  font-size: 0.8rem;
  margin-bottom: 0.5rem;
  color: var(--text);
  text-align: center;
}

.pile {
  width: var(--card-w);
  height: var(--card-h);
  border-radius: 5px;
  background-color: rgba(255, 255, 255, 0.1);
  display: flex;
  justify-content: center;
  align-items: center;
}

.deck {
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
}

.discard {
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
}

/* ======================= Disable non-playable interactivity ======================= */
/* Disable pointer events for all non-selectable card images */
.card-img:not(.selectable) {
  pointer-events: none !important;
}

/* Prevent hover effects on decks, discard, and opponent placeholders */
.deck:hover,
.discard:hover,
.player-area .opp-hand .card-placeholder:hover {
  transform: none !important;
  box-shadow: none !important;
  pointer-events: none !important;
}

/* Prevent interaction on opponent hand placeholders */
.player-area .opp-hand .card-placeholder {
  pointer-events: none !important;
}
/* Prevent interaction on draw and discard piles */
.deck, .discard {
  pointer-events: none !important;
}

/* ======================= Stack interactivity rules ======================= */
/* Disable all stack hover for non-playable stacks */
.stack {
  pointer-events: none !important;
}
/* Enable interaction only on playable stacks */
.stack.playable-stack {
  pointer-events: auto !important;
  cursor: pointer;
}
.stack.playable-stack .card-img {
  pointer-events: auto !important;
}

/* Ensure selectable cards always show gold outline on hover */
.card-img.selectable:hover {
  outline: 3px solid gold !important;
}

/* ======================= Selectable card styles ======================= */
.card-img.selected {
  transform: translateY(-10px) !important;
  box-shadow: 0 8px 16px rgba(0,0,0,0.5) !important;
  z-index: var(--z-card-selected); /* Updated z-index */
  outline: 3px solid gold !important; /* Persistent outline for selected cards */
}

.card-img.selectable {
  transition: transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
}

.card-img.selectable:hover {
  transform: translateY(-12px) scale(1.08) !important;
  box-shadow: 0 0 0 3px gold, 0 8px 20px rgba(255, 215, 0, 0.6) !important;
  outline: none !important; /* remove solid outline in favor of glow */
  z-index: var(--z-card-hover); /* Updated z-index */
}

/* Subtle alternating tilt on hover for natural feel */
.card-img.selectable:nth-child(odd):hover {
  transform: translateY(-12px) scale(1.08) rotate(-1deg) !important;
}
.card-img.selectable:nth-child(even):hover {
  transform: translateY(-12px) scale(1.08) rotate(1deg) !important;
}

/* ========== Selection Hover Override: only selectable cards react ========== */
.card-img.selectable:hover {
  transform: translateY(-10px) scale(1.05) !important;
  box-shadow: 0 5px 12px rgba(0,0,0,0.5) !important;
  outline: 3px solid gold !important;
  z-index: var(--z-card-hover); /* Updated z-index */
}

/* Disable all other hover-based transforms */
.card-img:hover,
.stack:hover .card-img,
.deck:hover,
.discard:hover,
.player-area .opp-hand .card-placeholder:hover {
  transform: none !important;
  box-shadow: none !important;
  outline: none !important;
}

/* Click state: slight deeper lift with stronger glow */
.card-img.selectable:active {
  transform: translateY(-12px) scale(1.06) !important;
  box-shadow: 0 0 6px gold, 0 6px 16px rgba(255,215,0,0.6) !important;
}

/* Hover brightness boost */
.card-img.selectable:hover {
  filter: brightness(1.08) !important;
}

/* Pulse animation for selected cards */
@keyframes selectedPulse {
  0% { box-shadow: 0 4px 8px rgba(255,215,0,0.4), 0 0 4px gold; }
  100% { box-shadow: 0 6px 12px rgba(255,215,0,0.6), 0 0 6px gold; }
}
.card-img.selected {
  animation: selectedPulse 1.5s ease-in-out infinite alternate;
  transition: none !important; /* rely on animation */
}

/* ========== Table Layout ========== */
.table {
  display: flex;
  justify-content: center;
  align-items: center;
  width: fit-content;
  height: fit-content;
  margin: auto;
  padding: 0; /* Remove outer padding to bring board edges closer */
  box-sizing: border-box;
  background: var(--bg); /* Use the dark green background */
}

.table-board {
  display: grid;
  grid-template-areas:
    '....  top    ....'
    'left center right'
    '.... bottom ....';
  grid-template-columns: auto auto auto;
  grid-template-rows: auto auto auto;
  gap: 0.75rem; /* Reduced spacing between player boards by half */
  margin: 0 auto;
  box-sizing: border-box;
  place-items: center; /* Center all grid items */
  background: var(--bg); /* Use the dark green background */
}

.table-slot-top, .table-slot-bottom, .table-slot-left, .table-slot-right, .table-slot-center {
  justify-content: center;
  align-items: center;
  padding: 0;
  margin: 0;
  width: auto; /* Let each slot shrink to its content rather than full width */
  display: flex;
  justify-content: center;
}

.table-slot-center {
  grid-area: center;
  align-self: center;
  justify-self: center;
}

.table-slot-top {
  grid-area: top;
  margin-bottom: 0; /* Remove overlap */
}

.table-slot-bottom {
  grid-area: bottom;
  margin-top: 0; /* Remove overlap */
}

.table-slot-left {
  grid-area: left;
  margin-right: 0; /* Remove overlap */
}

.table-slot-right {
  grid-area: right;
  margin-left: 0; /* Remove overlap */
}

@media (max-width: 1200px) {
  .table-board {
    grid-template-columns: 1fr 3fr 1fr;
    min-width: 0;
    max-width: 100vw;
  }
}
@media (max-width: 900px) {
  .table-board {
    display: flex;
    flex-direction: column;
    gap: 1.2rem;
    min-width: 0;
    max-width: 100vw;
    width: 100%;
  }
  .table-slot-top, .table-slot-bottom, .table-slot-left, .table-slot-right, .table-slot-center {
    width: 100%;
    justify-content: center;
    align-items: center;
  }
}

/* Only show play/take buttons for player-area in bottom slot */
.player-area .button-container {
  display: none !important;
}
.table-slot-bottom .button-container {
  display: flex !important;
}

.player-area,
#my-area {
  position: relative;
  /* match CPU padding */
  padding-top: 3rem !important; /* lessen space under banner */
  gap: 0.8rem !important;      /* tighter stacking of sections */
  min-height: 350px !important; /* shrink overall zone */
  max-width: calc(var(--card-w)*5 + 64px);
  min-height: 420px;
  max-height: 520px;
  border: 3px solid #ffffff !important; /* White border */
  background: var(--bg) !important; /* Green felt background */
  box-shadow: none !important; /* Remove previous shadows */
  border-radius: 12px;
  margin-top: 0 !important;
  margin-bottom: 0 !important;
  justify-content: center;
}

#my-area .player-section:first-of-type,
#my-area .player-section:last-of-type {
  margin-top: 1rem !important;
}

#my-area.active {
  border-color: #00CCCC !important; /* Changed to brighter teal (#00CCCC) */
  box-shadow: 0 0 20px 5px rgba(0, 204, 204, 0.4) !important; /* Updated glow color to match */
  animation: activePulse 1s infinite; /* Add pulsing animation for active state */
}

.player-area.active, .player.active {
  border-color: #00CCCC !important; /* Changed to brighter teal (#00CCCC) */
  box-shadow: 0 0 20px 5px rgba(0, 204, 204, 0.4) !important; /* Updated glow color to match */
  animation: activePulse 1s infinite; /* Add pulsing animation for active state */
}

@keyframes activePulse {
  0% { box-shadow: 0 0 20px 5px rgba(0, 204, 204, 0.4); }
  50% { box-shadow: 0 0 25px 8px rgba(0, 204, 204, 0.5); }
  100% { box-shadow: 0 0 20px 5px rgba(0, 204, 204, 0.4); }
}

.player-section {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.15rem;
  margin: 0 !important; /* remove extra margins between sections */
  outline: none !important;
}

.row-label {
  font-size: 1.4rem;
  font-weight: 700;
  color: #fff;
  letter-spacing: 0.5px;
  margin: 0.2rem 0 0.2rem 0;
  text-transform: none;
  text-align: center;
}

#my-area .row-label {
  color: #fff; /* Remove accent color */
}

#my-area .hand,
#my-area .stack-row,
#my-area #dynamic-btn-container,
#my-area .player-section {
  margin: 0 !important;
  outline: none !important;
}

#my-area .hand {
  margin-top: 0 !important;
}

#my-area .button-container {
  display: flex !important;
  justify-content: center;
  align-items: center;
  margin: 0 !important; /* remove custom top/bottom margins on buttons */
}

.player-area .button-container {
  display: none !important;
  margin: 0 !important; /* remove custom top/bottom margins on buttons */
}

.table-slot-bottom .button-container {
  display: flex !important;
}

.player-area .hand {
  display: flex;
  flex-direction: row; /* Ensure horizontal layout */
  gap: 0; /* Remove gap between cards */
  margin-top: 0.5rem;
  padding: 0.5rem;
  width: 100%;
  justify-content: center; /* Center cards in hand */
  align-items: center;
  position: relative;
  min-height: calc(var(--card-h) + 10px); /* Ensure height accommodates cards */
}

/* Hand cards shingling: apply to container, not image */
.player-area .hand .card-container {
  display: inline-block;
  position: relative;
  margin-right: -25px;
}
.player-area .hand .card-container:last-child {
  margin-right: 0;
}
/* Remove negative margin on images themselves to avoid conflicts */
.player-area .hand .card-img {
  margin-right: 0 !important;
}
/* Selected container bubbles forward and resets margin */
.card-container.selected-container {
  z-index: 50;
  margin-right: 5px;
}

/* Ensure opponent hand is also horizontal */
.player-area .opp-hand {
  display: flex;
  flex-direction: row; /* Ensure horizontal layout */
  gap: 0; /* Remove gap between cards if needed, adjust shingling margin */
  margin-top: 0.5rem;
  padding: 0.5rem;
  width: 100%;
  justify-content: center; /* Center cards in hand */
  align-items: center;
  position: relative;
  min-height: calc(var(--card-h) + 10px); /* Ensure height accommodates cards */
}

/* Player hand shingling */
.player-area .hand .card-img {
  margin-right: -25px; /* Negative margin for shingling effect */
  box-shadow: 2px 2px 6px rgba(0,0,0,0.4);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  cursor: pointer;
  position: relative;
  z-index: var(--z-card); /* Updated z-index */
}
.player-area .hand .card-img:last-child {
  margin-right: 0;
}
.player-area .hand .card-img:hover {
  transform: translateY(-10px) scale(1.05);
  box-shadow: 0 5px 12px rgba(0,0,0,0.5);
  z-index: var(--z-card-hover); /* Updated z-index */
}

/* Opponent hand shingling - Target the placeholder */
.player-area .opp-hand .card-placeholder {
  margin-right: -25px; /* Apply shingling to the placeholder */
  position: relative; /* Needed for z-index */
  transition: transform 0.2s ease, box-shadow 0.2s ease; /* Add transitions here */
}

.player-area .opp-hand .card-placeholder:last-child {
  margin-right: 0;
}

/* Apply hover effect to placeholder, which contains the card */
.player-area .opp-hand .card-placeholder:hover {
  transform: translateY(-10px) scale(1.05);
  box-shadow: 0 5px 12px rgba(0,0,0,0.5);
  z-index: var(--z-card-hover); /* Updated z-index */
}

/* Ensure the card image itself doesn't have conflicting margins */
.player-area .opp-hand .card-placeholder .card-img {
    margin-right: 0 !important; /* Override any inherited margin */
    /* Opponent cards are not interactive */
    cursor: default;
}

/* Remove all other borders from player panels */
.player-area *, .player *, #my-area * {
  border: none !important;
}

.player-section,        /* if youâ€™re using the .player-section wrapper */
.player-section .row-label {
  gap: 0.15rem !important;
}

.stack-row {
  display: flex;
  gap: 21px; /* Reduced from 42px to 21px for closer up/down cards */
  overflow: visible;
  min-height: 120px; /* Reduced from 156px to remove extra space */
  align-items: flex-start; /* Align stacks to the top so cards are right below label */
  justify-content: center;
  margin: 0 !important; /* Kill the extra top-margin */
  padding-top: 0 !important; /* remove extra padding above stacks */
  background: none !important;
}

/* Reset any conflicting stack styling and implement industry-standard with down cards peeking from top */
.stack {
  flex-shrink: 0;
  position: relative;
  width: var(--card-w);
  height: var(--card-h); /* Reduced from calc(var(--card-h) + 20px) to just the card height */
  margin-top: 20px; /* Space for down card to peek out */
  z-index: var(--z-base);
}

.stack .card-img.down-card {
  position: absolute !important;
  top: -20px !important;
  left: 50%;
  transform: translateX(-50%);
  z-index: calc(var(--z-card) - 1); /* Always below the up card */
}

.stack .card-img.up-card {
  position: absolute !important;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  z-index: var(--z-card); /* Base z-index for up cards */
}

.stack.playable-stack:hover .card-img.up-card,
.stack.playable-stack:hover .card-img.down-card {
  transform: translateX(-50%) translateY(-10px) scale(1.05);
  box-shadow: 0 5px 12px rgba(0,0,0,0.45);
  z-index: var(--z-card-hover); /* Higher z-index when hovering */
}

.stack.playable-stack .card-img.up-card.selected,
.stack.playable-stack .card-img.down-card.selected {
  z-index: var(--z-card-selected); /* Highest z-index when selected */
}

/* Allow selecting cards during pile transition */
.card-img.selectable {
  cursor: pointer !important;
  pointer-events: auto !important;
}

/* Remove conflicting styles */
.stack .up-card {
  top: 0 !important; /* Override any other top settings */
}

/* Maintain hover effects for stacks */
.stack .card-img.up-card:hover,
.stack .card-img.down-card:hover {
  transform: translateX(-50%) translateY(-10px) scale(1.05);
  box-shadow: 0 5px 12px rgba(0,0,0,0.45);
  z-index: var(--z-card-hover); /* Updated z-index */
}

/* --- Only one authoritative rule for peeking down cards in stack --- */
.stack .card-img.down-card {
  position: absolute !important;
  top: -20px !important;
  left: 50%;
  transform: translateX(-50%);
  z-index: calc(var(--z-card) - 1); /* Updated z-index */
}

/* ========== Event Banner ========== */
#event-banner {
  position: absolute; /* Change from relative to absolute */
  top: -40px !important; /* Move banner up slightly */
  left: 50%;
  transform: translateX(-50%);
  padding: 8px 16px;
  border-radius: 4px;
  font-size: 1rem; /* consistent size */
  font-weight: bold;
  color: white;
  text-align: center;
  z-index: 120; /* Keep z-index */
  opacity: 0;
  transition: opacity 0.3s ease-in-out;
  pointer-events: none;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
  width: fit-content; /* Ensure banner width fits content */
  white-space: nowrap; /* Prevent wrapping */
}

.event-banner-visible {
  opacity: 1 !important;
}

.event-banner-visible.burn {
  background-color: #ff4500;
}

.event-banner-visible.reset {
  background-color: #4caf50;
}

.event-banner-visible.copy {
  background-color: #2196f3;
}

.error-banner {
  position: absolute;
  top: -40px !important;
  left: 50%;
  transform: translateX(-50%);
  padding: 8px 16px;
  background-color: var(--error-color);
  color: white;
  border-radius: 4px;
  font-size: 1rem;
  z-index: 100;
}

/* ========== Buttons ========== */
.button-container {
  background: none !important;
  border: none !important;
  box-shadow: none !important;
  padding: 0.5rem 0 0 0;
  margin: 0 !important;
  display: flex;
  gap: 0.5rem; /* tighter spacing */
  max-width: none;
  outline: none !important;
}
.button-container .btn {
  width: auto !important; /* allow side-by-side */
  padding: 0.4rem 0.8rem; /* smaller buttons */
  font-size: 0.9rem; /* slightly smaller text */
}
#table .button-container {
  margin-bottom: 0.5rem; /* Ensure button container sits close above piles */
}

#play {
  background: #FFC800; /* Changed to #FFC800 gold */
  color: #000000; /* Black text for better contrast */
  text-shadow: none;
  padding: 0.7rem 1.2rem; /* Adjusted padding for shorter text */
  font-weight: 700;
}

#take {
  background: #FFC800; /* Changed to #FFC800 gold */
  color: #000000; /* Black text for better contrast */
  padding: 0.7rem 1.2rem; /* Adjusted padding for shorter text */
  font-weight: 700;
}

.button-container button:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.button-container button:active:not(:disabled) {
  transform: translateY(0);
}

.button-container button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none; /* Added missing semicolon */
}

/* Play Options */
.play-options {
  display: flex;
  gap: 0.5rem;
}

.play-options button {
  min-width: 120px;
}

#join-computer {
  background: var(--accent2);
  color: white;
}

/* ========== Toast Notifications ========== */
#toast-container {
  position: fixed;
  top: 1rem;
  right: 1rem;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 0.5rem;
  z-index: var(--z-toast);
  pointer-events: none;
}
.toast {
  background: rgba(0, 0, 0, 0.85);
  color: #ffffff;
  padding: 0.75rem 1.25rem;
  border-radius: 0.5rem;
  font-size: 0.9rem;
  box-shadow: 0 2px 6px rgba(0,0,0,0.5);
  pointer-events: auto;
  animation: toastInOut 2.5s ease forwards;
}
@keyframes toastInOut {
  0% { opacity: 0; transform: translateY(-10px); }
  10%, 80% { opacity: 1; transform: translateY(0); }
  100% { opacity: 0; transform: translateY(-10px); }
}

/* Special card icon (fallback style) */
.special-icon {
  pointer-events: none;
  user-select: none;
  background: transparent !important;
  z-index: var(--z-card-icon); /* Updated z-index */
  filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.7));
}
.special-icon img {
  background: transparent !important;
  display: block;
}

/* ========== Special Effect Animation ========== */
@keyframes iconPulse {
  0% { transform: translate(-50%, -50%) scale(0.9); opacity: 0; }
  20% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
  70% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
  100% { transform: translate(-50%, -50%) scale(1); opacity: 0.9; }
}

/* Optimize the ring-pulse animation to be less CPU intensive */
@keyframes ring-pulse {
  0% { box-shadow: 0 0 0 rgba(255, 215, 0, 0); }
  50% { box-shadow: 0 0 10px 3px rgba(255, 215, 0, 0.8); }
  100% { box-shadow: 0 0 0 rgba(255, 215, 0, 0); }
}

.ring-pulse {
  animation: ring-pulse 0.7s ease-out;
}

/* ========== Responsive Styles ========== */
@media (max-height: 800px) {
  .card-img {
    width: var(--card-w);
    height: var(--card-h);
  }
  
  .pile {
    width: var(--card-w);
    height: var(--card-h);
  }
  
  #center {
    min-height: 100px;
    padding: 0.75rem;
  }
  
  .stack {
    width: var(--card-w);
    height: calc(var(--card-h) + var(--card-peek));
  }
  .stack .card-img {
    width: var(--card-w);
    height: var(--card-h);
  }
  .stack .card-img.down-card {
    top: var(--card-peek);
  }
  .stack .card-img.up-card {
     top: 0;
  }

  .hand, .opp-hand, .stack-row {
    padding: 0.5rem 0.5rem 0.8rem 0.5rem; /* Added extra bottom padding for smaller screens */
  }

  .player, #my-area {
    padding: 0.8rem 0.8rem 1.2rem 0.8rem; /* Keep some base bottom padding here */
    gap: 0.4rem; /* Also adjust gap here */
  }
}

@media (max-width: 1200px) {
  #other-players, #my-area {
    min-width: 300px;
  }
}

@media (max-width: 1000px) {
  #other-players, #my-area, #center {
    min-width: 0;
    max-width: 95%; /* Allow slightly wider on mobile */
    width: 100%;
    flex: 1 0 auto;
    margin: 0 auto;
    order: 0; /* Reset order for column layout */
    align-self: center; /* Ensure centering in column layout too */
  }
  
  #center {
    margin: 1rem auto; /* Vertical margin */
    order: 2; /* Keep center between players */
    flex-direction: row; /* Ensure piles stay side-by-side */
    align-items: center; /* Center piles internally on mobile */
  }
  
  #other-players {
    order: 1; /* Opponent first */
  }
  
  #my-area {
    order: 3; /* Player last */
  }
}

@media (max-width: 600px) {
  :root {
    --card-w: 44px;
    --card-h: 60px;
  }

  body {
    padding-top: calc(var(--header-height) + 10px); /* Adjust padding if header wraps */
  }
  .header-content {
    flex-direction: column; /* Stack header items */
    align-items: flex-start; /* Align left */
    padding: 0.5rem 1rem; /* Adjust padding */
    gap: 0.5rem;
  }
  #main-header {
    height: auto; /* Allow header height to adjust */
    position: static; /* Unfix header on mobile? Or keep fixed? Let's keep fixed for now */
  }
  #rules[open] {
    right: 1rem;
    top: calc(100% + 5px); /* Position below header content */
    width: calc(100% - 2rem); /* Adjust width */
  }

  #lobby-form-card {
    width: 90%; /* Wider card on mobile */
    padding: calc(var(--gutter) * 0.75); /* Slightly less padding */
  }

  #lobby-heading {
    font-size: 24px; /* Slightly smaller heading */
  }

  .button-group {
    flex-direction: column; /* Stack buttons */
    gap: 0.75rem;
  }

  .computer-options {
    flex-direction: column; /* Stack computer options */
    align-items: flex-start;
  }
  .computer-options input[type="number"] {
    width: 100%; /* Full width input */
  }

  #table {
    padding: 0.5rem;
    margin-top: -1rem; /* reduce green gap above top player */
  }
  
  #center {
    gap: 1rem;
    padding: 0.75rem;
    flex-direction: row; /* Ensure horizontal layout even on small screens */
  }
  
  .stack-row {
    justify-content: flex-start;
    padding: 0.5rem 0;
  }
  
  .hand, .opp-hand {
    justify-content: flex-start;
    padding: 0.5rem 0;
  }

  .button-container {
    flex-direction: column;
    padding: 0.5rem;
    margin-top: 0.5rem;
  }
  
  .button-container button {
    width: 100%;
    margin: 0;
  }

  #other-players {
    margin-bottom: 1.2rem;
  }
  #my-area {
    order: 3; /* Player last */
    margin-top: 1.2rem; /* Add margin back for spacing */
  }

  /* Modal takes more width on mobile */
  .modal {
    width: 95%;
    max-width: 95%;
  }
  .modal-content {
    padding: var(--gutter);
  }
}

@media (max-width: 480px) {
  #center {
    min-width: 150px; /* Even smaller minimum width */
  }
  
  .player, #my-area {
    padding: 1rem; /* Further reduce padding */
  }
}

/* CPU-specific spacing tweaks */
.computer-player {
  gap: 1.2rem !important;  /* larger space between up/down sections */
}
.computer-player .player-section:first-of-type {
  margin-top: 1rem !important; /* restore original spacing under banner */
}

/* Human-specific spacing tweaks */
#my-area {
  gap: 1.2rem !important;
  min-height: 460px !important;
}
#my-area .player-section:first-of-type {
  margin-top: 1rem !important;
}
#my-area .player-section:last-of-type {
  gap: 1rem !important;
}
#my-area .hand {
  margin-top: 0 !important;
}

/* ========== Human player banner & section spacing fixes ========== */
#my-area .player-name-header {
  margin-bottom: 0.5rem !important;  /* restore space below banner */
}
#my-area .player-section:first-of-type {
  margin-top: 1rem !important;      /* move Hand label/row down */
}
#my-area #dynamic-btn-container {
  margin-top: 1rem !important;      /* space between Hand and buttons */
  margin-bottom: 0 !important;
}
#my-area .player-section:last-of-type {
  margin-top: 1rem !important;      /* space between buttons and Up/Down section */
  gap: 1rem !important;             /* space between Up/Down label and cards */
}

/* Shrink player name banners */
.player-area .player-name-header,
#my-area .player-name-header {
  font-size: 1.2rem !important;
  height: 2.2rem !important;
  padding: 0.4rem 0.8rem !important;
}

/* Ring pulse animation for discard pile highlight */
@keyframes ringPulse {
  0% { box-shadow: 0 0 0 0 var(--accent); }
  50% { box-shadow: 0 0 0 0.5rem var(--accent); }
  100% { box-shadow: 0 0 0 0 var(--accent); }
}
.discard.ring-pulse {
  animation: ringPulse 0.7s ease-out;
}

/* Add Game Log panel styling */
#game-log {
  position: fixed;
  bottom: 1rem;
  right: 1rem;
  width: 260px;
  max-height: 300px;
  background: var(--card-bg);
  border: 1px solid var(--input-border);
  border-radius: 8px;
  padding: var(--gutter);
  overflow-y: auto;
  z-index: var(--z-toast);
  pointer-events: auto;
}
#game-log h3 {
  margin-bottom: 0.5rem;
  font-size: 1.1rem;
}
#game-log-entries div {
  margin-bottom: 0.3rem;
  cursor: default;
}
</file>

<file path="public/client.js">
// Wrap the main logic in DOMContentLoaded
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOM fully loaded and parsed'); // New log

  // Preload all card images to eliminate first-render flash
  (function preloadAllCardImages() {
    const suits = ['H','D','C','S'];
    const values = ['2','3','4','5','6','7','8','9','0','J','Q','K','A'];
    suits.forEach(s => values.forEach(v => {
      const img = new Image();
      img.src = `https://deckofcardsapi.com/static/img/${v}${s}.png`;
    }));
    const back = new Image();
    back.src = 'https://deckofcardsapi.com/static/img/back.png';
    // Preload special icons
    ['Reset-icon.png','Copy-icon.png','Burn-icon.png','Invalid play-icon.png','Take pile-icon.png'].forEach(name => {
      const img = new Image();
      img.src = name;
    });
  })();

  const socket = io({
    reconnectionDelayMax: 10000,
    reconnection: true,
    reconnectionDelay: 1000,
  });

  console.log('Top That! client.js version 20250424_lobby_modal loaded');

  /* ---------- DOM Refs ---------- */
  const $ = id => document.getElementById(id);

  // Lobby elements
  const lobbyContainer = $('lobby-container');
  const lobbyFormCard = $('lobby-form-card');
  const lobbyFormContent = $('lobby-form-content');
  const waitingStateDiv = $('waiting-state');
  const nameIn = $('name');
  const nameError = $('name-error');
  const joinBtn = $('join');
  const joinComputerBtn = $('join-computer');
  const tutorialBtn = $('tutorial-btn');
  const computerCountInput = $('computer-count');
  const copyLinkBtn = $('copy-link-button');
  const shareLinkMessage = $('share-link-message');

  // Modal elements
  const modalOverlay = $('modal-overlay');
  const rulesModal = $('rules-modal');
  const rulesButton = $('rules-button');
  const rulesModalCloseButton = rulesModal ? rulesModal.querySelector('.modal-close-button') : null;

  // Reference the game table element for showGameTable
  const table = $('table');

  // Remove dev restart functionality
  function addRestartButton() {}
  function addRestartButtons() {}

  // After reload, auto-trigger Play vs Computer if requested
  if (sessionStorage.getItem('autoPlayVsComputer') === '1') {
    sessionStorage.removeItem('autoPlayVsComputer');
    setTimeout(() => {
      if (typeof joinComputerBtn?.onclick === 'function') {
        joinComputerBtn.onclick();
      } else {
        // fallback: simulate click
        joinComputerBtn?.click();
      }
    }, 300);
  }

  // Global state
  let myId = null;
  let currentRoom = null;
  let activeModal = null; // Keep track of the currently open modal
  let pileTransition = false; // Track if the pile is in a transition state (e.g., after 5, 10, or four-of-a-kind)
  let specialEffectsQueue = []; // Queue to track pending specialEffects for banner display
  let processingEffects = false; // Flag to track if we're currently processing effects
  let actionHistory = []; // Track user-initiated actions for replay
  
  // Debugging system for tracking game logic inconsistencies
  const gameDebug = {
    enabled: true,
    lastHumanPlay: null,
    lastCPUPlay: null,
    specialCardPlays: [],
    turnChanges: [],
    stateUpdates: [],
    renderTimes: [],
    effectSequence: [],
    gameEvents: [], // Unified chronological event log
    eventCounter: 0, // For sequence numbering
    startTime: Date.now(),
    maxEntries: 100,
    
    // Format timestamp with millisecond precision
    formatTimestamp: function(timestamp) {
      const d = new Date(timestamp);
      return `${d.toLocaleTimeString()}.${String(d.getMilliseconds()).padStart(3, '0')}`;
    },
    
    // Format time elapsed in ms with + prefix for readability
    formatElapsed: function(elapsed) {
      return (elapsed >= 0 ? '+' : '') + elapsed + 'ms';
    },
    
    // Log any game event with precise timing
    logEvent: function(category, action, details) {
      if (!this.enabled) return;
      
      const timestamp = Date.now();
      const elapsedFromStart = timestamp - this.startTime;
      
      // Find the most recent event for relative timing
      const lastEvent = this.gameEvents.length > 0 ? this.gameEvents[this.gameEvents.length - 1] : null;
      const elapsed = lastEvent ? timestamp - lastEvent.timestamp : 0;
      
      const event = {
        seq: ++this.eventCounter,
        category,
        action,
        details,
        timestamp,
        elapsedFromStart,
        elapsed,
        relativeToLastSameType: this.getTimeSinceLastSameType(category, timestamp)
      };
      
      this.gameEvents.push(event);
      if (this.gameEvents.length > this.maxEntries * 2) {
        this.gameEvents.shift();
      }
      
      // Log formatted output to console
      console.log(`[DEBUG:${event.seq}] [${this.formatTimestamp(timestamp)}] [${this.formatElapsed(elapsed)}] [${category}] ${action}${details ? ': ' + JSON.stringify(details) : ''}`);
      
      // Update the debug panel
      this.updateDebugPanel();
      
      return event;
    },
    
    // Get time elapsed since last event of same category
    getTimeSinceLastSameType: function(category, timestamp) {
      for (let i = this.gameEvents.length - 1; i >= 0; i--) {
        if (this.gameEvents[i].category === category && this.gameEvents[i].timestamp < timestamp) {
          return timestamp - this.gameEvents[i].timestamp;
        }
      }
      return null;
    },
    
    // Track when human player makes a play
    logHumanPlay: function(cards) {
      if (!this.enabled) return;
      
      this.lastHumanPlay = {
        timestamp: Date.now(),
        cards: Array.isArray(cards) ? [...cards] : cards,
      };
      
      this.logEvent('PLAY', 'Human played', {
        cards: Array.isArray(cards) ? 
          cards.map(c => (c.value + (c.suit ? ' ' + c.suit[0] : ''))) : 
          cards
      });
    },
    
    // Track CPU plays and calculate response time
    logCPUPlay: function(playerId, cards) {
      if (!this.enabled) return;
      
      const now = Date.now();
      this.lastCPUPlay = {
        timestamp: now,
        playerId,
        cards: Array.isArray(cards) ? [...cards] : cards,
        responseTime: this.lastHumanPlay ? (now - this.lastHumanPlay.timestamp) : null
      };
      
      // Alert if CPU plays too quickly (might indicate a logic bug)
      let alertText = null;
      if (this.lastHumanPlay && this.lastCPUPlay.responseTime < 300) {
        alertText = `Fast CPU play detected: ${this.lastCPUPlay.responseTime}ms response time`;
        console.warn(`[DEBUG] CPU played suspiciously fast: ${this.lastCPUPlay.responseTime}ms after human play`);
        this.addDebugAlert(alertText);
      }
      
      this.logEvent('PLAY', 'CPU played', {
        playerId,
        cards: Array.isArray(cards) ? 
          cards.map(c => (c.value + (c.suit ? ' ' + c.suit[0] : ''))) : 
          cards,
        responseTime: this.lastCPUPlay.responseTime,
        suspiciouslyFast: alertText !== null
      });
    },
    
    // Track special card effects with precise timing
    logSpecialEffect: function(value, type, currentTurn, nextTurn, phase = "queued") {
      if (!this.enabled) return;
      
      const timestamp = Date.now();
      const effect = {
        timestamp,
        seq: ++this.eventCounter,
        value,
        type,
        currentTurn,
        nextTurn,
        phase
      };
      
      this.specialCardPlays.push(effect);
      if (this.specialCardPlays.length > this.maxEntries) {
        this.specialCardPlays.shift();
      }
      
      // Also add to unified event log
      this.logEvent('EFFECT', `${type} effect ${phase}`, {
        value, 
        type, 
        currentTurn, 
        nextTurn
      });
    },
    
    // Track effect animation phases
    logEffectPhase: function(effectId, phase, details = {}) {
      if (!this.enabled) return;
      
      const timestamp = Date.now();
      const sequenceItem = {
        timestamp,
        effectId,
        phase,
        details
      };
      
      this.effectSequence.push(sequenceItem);
      if (this.effectSequence.length > this.maxEntries * 2) {
        this.effectSequence.shift();
      }
      
      this.logEvent('EFFECT_PHASE', `${effectId} - ${phase}`, details);
    },
    
    // Track turn changes with precise timing
    logTurnChange: function(fromPlayer, toPlayer) {
      if (!this.enabled) return;
      
      const timestamp = Date.now();
      const change = {
        timestamp,
        seq: ++this.eventCounter,
        from: fromPlayer,
        to: toPlayer
      };
      
      this.turnChanges.push(change);
      if (this.turnChanges.length > this.maxEntries) {
        this.turnChanges.shift();
      }
      
      // Calculate time since last turn change for this player
      let lastTurnTime = null;
      for (let i = this.turnChanges.length - 2; i >= 0; i--) {
        if (this.turnChanges[i].to === fromPlayer) {
          lastTurnTime = timestamp - this.turnChanges[i].timestamp;
          break;
        }
      }
      
      this.logEvent('TURN', `${fromPlayer} â†’ ${toPlayer}`, {
        fromPlayer,
        toPlayer,
        turnDuration: lastTurnTime
      });
    },
    
    // Track state updates with timing data
    logStateUpdate: function(state, renderStart) {
      if (!this.enabled) return;
      
      const timestamp = Date.now();
      const stateUpdate = {
        timestamp,
        seq: ++this.eventCounter,
        turn: state.turn,
        playPileLength: state.playPile ? state.playPile.length : 0,
        deckCount: state.deckCount,
        playerHandCounts: state.players.map(p => ({ id: p.id, handCount: p.handCount }))
      };
      
      this.stateUpdates.push(stateUpdate);
      if (this.stateUpdates.length > this.maxEntries) {
        this.stateUpdates.shift();
      }
      
      this.logEvent('STATE', `Updated game state`, {
        turn: state.turn,
        playPileLength: state.playPile ? state.playPile.length : 0,
        lastCard: state.playPile && state.playPile.length > 0 ? 
          state.playPile[state.playPile.length - 1].value : 'none',
        isFirstState: this.stateUpdates.length === 1,
        renderStarted: renderStart ? 'yes' : 'no'
      });
      
      if (renderStart) {
        // Start tracking render time
        this.currentRenderStart = timestamp;
      }
    },
    
    // Track render completion times
    logRenderComplete: function() {
      if (!this.enabled || !this.currentRenderStart) return;
      
      const timestamp = Date.now();
      const renderTime = {
        timestamp,
        seq: ++this.eventCounter,
        renderStart: this.currentRenderStart,
        renderDuration: timestamp - this.currentRenderStart
      };
      
      this.renderTimes.push(renderTime);
      if (this.renderTimes.length > this.maxEntries) {
        this.renderTimes.shift();
      }
      
      this.logEvent('RENDER', `Render completed`, {
        duration: renderTime.renderDuration
      });
      
      this.currentRenderStart = null;
    },
    
    // Create and update visual debug panel
    createDebugPanel: function() {
      if (document.getElementById('game-debug-panel')) return;
      
      const panel = document.createElement('div');
      panel.id = 'game-debug-panel';
      panel.style.cssText = `
        position: fixed;
        bottom: 10px;
        right: 10px;
        width: 450px;
        max-height: 400px;
        background: rgba(0, 0, 0, 0.85);
        color: #33ff33;
        border: 1px solid #33ff33;
        border-radius: 5px;
        padding: 12px;
        font-family: 'Courier New', monospace;
        font-size: 13px;
        font-weight: 600;
        letter-spacing: 0.5px;
        line-height: 1.5;
        z-index: 10000;
        overflow-y: auto;
        transition: opacity 0.3s;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      `;
      
      const header = document.createElement('div');
      header.style.cssText = `
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
        padding-bottom: 8px;
        border-bottom: 1px solid #33ff33;
        font-size: 14px;
      `;
      
      // Create panel controls
      const controlsDiv = document.createElement('div');
      controlsDiv.style.display = 'flex';
      controlsDiv.style.gap = '8px';
      
      const titleSpan = document.createElement('span');
      titleSpan.innerHTML = '<strong>Advanced Debug Panel</strong>';
      
      const toggleBtn = document.createElement('button');
      toggleBtn.textContent = 'Hide';
      toggleBtn.style.cssText = `
        background: #111;
        color: #33ff33;
        border: 1px solid #33ff33;
        border-radius: 3px;
        padding: 2px 8px;
        cursor: pointer;
      `;
      
      const exportBtn = document.createElement('button');
      exportBtn.textContent = 'Export';
      exportBtn.style.cssText = `
        background: #111;
        color: #33ff33;
        border: 1px solid #33ff33;
        border-radius: 3px;
        padding: 2px 8px;
        cursor: pointer;
      `;
      
      toggleBtn.onclick = () => {
        const content = document.getElementById('debug-panel-content');
        if (content.style.display === 'none') {
          content.style.display = 'block';
          toggleBtn.textContent = 'Hide';
          panel.style.opacity = '1';
        } else {
          content.style.display = 'none';
          toggleBtn.textContent = 'Show';
          panel.style.opacity = '0.6';
        }
      };
      
      exportBtn.onclick = () => this.exportDebugData();
      
      controlsDiv.appendChild(toggleBtn);
      controlsDiv.appendChild(exportBtn);
      
      header.appendChild(titleSpan);
      header.appendChild(controlsDiv);
      panel.appendChild(header);
      
      const content = document.createElement('div');
      content.id = 'debug-panel-content';
      content.innerHTML = '<div>Enhanced timing debug active...</div>';
      panel.appendChild(content);
      
      const alerts = document.createElement('div');
      alerts.id = 'debug-alerts';
      alerts.style.cssText = `
        margin-top: 10px;
        padding-top: 8px;
        border-top: 1px dashed #ff5555;
        color: #ff5555;
      `;
      content.appendChild(alerts);
      
      document.body.appendChild(panel);
    },
    
    updateDebugPanel: function() {
      this.createDebugPanel();
      const content = document.getElementById('debug-panel-content');
      if (!content) return;
      
      let html = '<div style="margin-bottom: 12px;"><strong>Timing Analysis:</strong></div>';
      
      // Show event timeline (most recent first)
      html += '<div style="margin-bottom: 10px;"><strong>Recent Events (Newest First):</strong></div>';
      html += '<table style="width:100%; font-size:12px; border-collapse:collapse;">';
      html += '<tr style="text-align:left; border-bottom:1px solid #33ff33;">';
      html += '<th>#</th><th>Time</th><th>Î”</th><th>Type</th><th>Detail</th>';
      html += '</tr>';
      
      // Show most recent 10 events
      this.gameEvents.slice(-10).reverse().forEach(event => {
        // Set color based on category
        let rowColor = '';
        if (event.category === 'TURN') rowColor = 'color:#ffd700;'; // Gold
        else if (event.category === 'PLAY') rowColor = 'color:#00ffff;'; // Cyan
        else if (event.category.includes('EFFECT')) rowColor = 'color:#ff00ff;'; // Magenta
        else if (event.category === 'STATE') rowColor = 'color:#7fff00;'; // Chartreuse
        else if (event.category === 'RENDER') rowColor = 'color:#ff7f50;'; // Coral
        
        html += `<tr style="${rowColor}">`;
        html += `<td>${event.seq}</td>`;
        html += `<td>${this.formatTimestamp(event.timestamp)}</td>`;
        html += `<td>${this.formatElapsed(event.elapsed)}</td>`;
        html += `<td>${event.category}</td>`;
        html += `<td>${event.action}</td>`;
        html += `</tr>`;
      });
      html += '</table>';
      
      // Timing specific concerns
      if (this.turnChanges.length > 0) {
        const lastTurnChange = this.turnChanges[this.turnChanges.length - 1];
        html += `<div style="margin-top:12px;"><strong>Last turn change:</strong> ${lastTurnChange.from} â†’ ${lastTurnChange.to} (${this.formatTimestamp(lastTurnChange.timestamp)})</div>`;
      }
      
      if (this.renderTimes.length > 0) {
        const lastRender = this.renderTimes[this.renderTimes.length - 1];
        html += `<div><strong>Last render time:</strong> ${lastRender.renderDuration}ms</div>`;
      }
      
      // Show alerts section
      const alerts = document.getElementById('debug-alerts');
      if (alerts) {
        // Keep existing alerts
        const existingAlerts = alerts.innerHTML;
        content.innerHTML = html;
        alerts.innerHTML = existingAlerts;
        content.appendChild(alerts);
      } else {
        content.innerHTML = html;
      }
    },
    
    addDebugAlert: function(message) {
      const alerts = document.getElementById('debug-alerts');
      if (!alerts) return;
      
      const alert = document.createElement('div');
      alert.textContent = `âš ï¸ ${message}`;
      alert.style.color = '#ff5555';
      alert.style.marginBottom = '5px';
      alert.style.fontWeight = 'bold';
      
      // Add to unified event log
      this.logEvent('ALERT', message);
      
      // Add alert with animation
      alerts.appendChild(alert);
      
      // Remove after 15 seconds
      setTimeout(() => {
        if (alert.parentNode === alerts) {
          alert.style.opacity = '0';
          alert.style.transition = 'opacity 1s';
          setTimeout(() => {
            if (alert.parentNode === alerts) {
              alerts.removeChild(alert);
            }
          }, 1000);
        }
      }, 15000);
    },
    
    // Export debug data in a copy-pastable format
    exportDebugData: function() {
      // Create CSV for timeline events
      let csv = "Seq,Timestamp,Elapsed,Category,Action,Details\n";
      this.gameEvents.forEach(event => {
        const timestamp = this.formatTimestamp(event.timestamp);
        const elapsed = this.formatElapsed(event.elapsed);
        const details = JSON.stringify(event.details || {}).replace(/"/g, '""'); // Escape quotes for CSV
        csv += `${event.seq},"${timestamp}","${elapsed}","${event.category}","${event.action}","${details}"\n`;
      });
      
      // Create a downloadable file
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      
      // Create a temporary link and trigger download
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', `top-that-debug-${Date.now()}.csv`);
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      // Create a JSON export for clipboard
      const jsonExport = {
        timestamp: Date.now(),
        events: this.gameEvents,
        turnChanges: this.turnChanges,
        specialEffects: this.specialCardPlays,
        renderTimes: this.renderTimes
      };
      
      // Copy JSON to clipboard
      const jsonText = JSON.stringify(jsonExport, null, 2);
      navigator.clipboard.writeText(jsonText).then(() => {
        this.addDebugAlert("Debug data copied to clipboard and CSV file downloaded");
      }).catch(err => {
        this.addDebugAlert("Error copying to clipboard. CSV file downloaded.");
        console.error("Error copying debug data: ", err);
      });
      
      return jsonExport;
    },
    
    // Get diagnostics data as an object
    getDiagnostics: function() {
      return {
        timestamp: Date.now(),
        events: this.gameEvents.slice(-30),
        turnChanges: this.turnChanges.slice(-10),
        specialEffects: this.specialCardPlays.slice(-10),
        renderTimes: this.renderTimes.slice(-10),
        summary: {
          totalEvents: this.gameEvents.length,
          lastEventTime: this.gameEvents.length > 0 ? 
            this.gameEvents[this.gameEvents.length-1].timestamp : null,
          averageRenderTime: this.calculateAverageRenderTime(),
          maxRenderTime: this.calculateMaxRenderTime()
        }
      };
    },
    
    // Calculate average render time
    calculateAverageRenderTime: function() {
      if (this.renderTimes.length === 0) return null;
      const sum = this.renderTimes.reduce((sum, item) => sum + item.renderDuration, 0);
      return Math.round(sum / this.renderTimes.length);
    },
    
    // Calculate maximum render time
    calculateMaxRenderTime: function() {
      if (this.renderTimes.length === 0) return null;
      return Math.max(...this.renderTimes.map(item => item.renderDuration));
    },
    
    // Show diagnostic report (can be triggered from console)
    showDiagnostics: function() {
      const data = this.getDiagnostics();
      
      console.group('Game Diagnostics Report');
      console.log(`Total events: ${data.events.length}`);
      console.log(`Last event: ${data.events.length > 0 ? this.formatTimestamp(data.events[data.events.length-1].timestamp) : 'none'}`);
      console.log(`Average render time: ${data.summary.averageRenderTime}ms`);
      console.log(`Max render time: ${data.summary.maxRenderTime}ms`);
      
      console.log('Recent events (newest first):');
      data.events.slice().reverse().forEach(event => {
        console.log(`[${this.formatTimestamp(event.timestamp)}] [${this.formatElapsed(event.elapsed)}] [${event.category}] ${event.action}`);
      });
      
      console.log('Recent turn changes:');
      data.turnChanges.slice(-5).forEach(change => {
        console.log(`[${this.formatTimestamp(change.timestamp)}] ${change.from} â†’ ${change.to}`);
      });
      
      console.log('Recent special effects:');
      data.specialEffects.slice(-5).forEach(effect => {
        console.log(`[${this.formatTimestamp(effect.timestamp)}] ${effect.type} (value: ${effect.value})`);
      });
      console.groupEnd();
      
      this.createDebugPanel();
      this.updateDebugPanel();
      
      // Print instructions
      console.log('Use gameDebug.exportDebugData() to download timing data or copy to clipboard');
      
      return data;
    },
    
    // Toggle debug panel visibility
    togglePanel: function() {
      const panel = document.getElementById('game-debug-panel');
      if (panel) {
        if (panel.style.display === 'none') {
          panel.style.display = 'block';
        } else {
          panel.style.display = 'none';
        }
      } else {
        this.createDebugPanel();
      }
    },

    // Add tracking for take pile events to gameDebug object
    logTakePileEvent: function(playerId, isForced = false) {
      if (!this.enabled) return;
      
      const timestamp = Date.now();
      const event = {
        timestamp,
        seq: ++this.eventCounter,
        playerId,
        isForced
      };
      
      this.logEvent('PILE_TAKE', isForced ? 'Forced take pile' : 'Voluntary take pile', {
        playerId,
        isForced
      });
    }
  };
  
  // Make debugging accessible from console and add keyboard shortcut
  window.gameDebug = gameDebug;
  
  // Add keyboard shortcut (Ctrl+Shift+D) to toggle debug panel
  document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.shiftKey && e.key === 'D') {
      e.preventDefault();
      gameDebug.togglePanel();
    }
  });

  // Read room parameter from URL
  const urlParams = new URLSearchParams(window.location.search);
  const initialRoom = urlParams.get('room') || null;

  // If joining an existing room, hide setup inputs
  if (initialRoom) {
    const setup = $('setup-fields');
    if (setup) setup.classList.add('hidden');
    const totalField = $('total-players');
    if (totalField) totalField.disabled = true;
    const cpuField = $('computer-count');
    if (cpuField) cpuField.disabled = true;
    const btn = $('create-join');
    if (btn) btn.textContent = 'Join Game';
  }

  /* ---------- UI State Functions ---------- */

  function showOverlay() {
    console.log('[Debug] showOverlay called'); // Re-added log
    if (modalOverlay) modalOverlay.classList.remove('hidden');
    else console.error('[Debug Error] modalOverlay is null in showOverlay'); // Added check
  }
  function hideOverlay() {
    console.log('[Debug] hideOverlay called'); // Re-added log
    if (modalOverlay && !activeModal) {
      modalOverlay.classList.add('hidden');
    } else if (!modalOverlay) {
       console.error('[Debug Error] modalOverlay is null in hideOverlay'); // Added check
    }
  }

  function showLobbyForm() {
    console.log('[Debug] showLobbyForm called'); // Re-added log

    // Log initial state & check elements
    console.log('[Debug] Before changes:');
    if (modalOverlay) console.log(`  - modalOverlay classes: ${modalOverlay.className}`);
    else console.error('[Debug Error] modalOverlay is null in showLobbyForm (start)');
    if (lobbyContainer) console.log(`  - lobbyContainer classes: ${lobbyContainer.className}`);
    else console.error('[Debug Error] lobbyContainer is null in showLobbyForm (start)');
    const lobbyCardInitial = $('lobby-form-card');
    if (lobbyCardInitial) console.log(`  - lobby-form-card opacity: ${lobbyCardInitial.style.opacity}`);
    else console.error('[Debug Error] lobby-form-card is null in showLobbyForm (start)');

    if (modalOverlay) modalOverlay.classList.add('hidden'); // Force hide overlay
    if (lobbyContainer) lobbyContainer.classList.remove('hidden');
    if (lobbyFormContent) lobbyFormContent.classList.remove('hidden');
    if (waitingStateDiv) waitingStateDiv.classList.add('hidden');
    if (nameIn) {
      nameIn.value = '';
      nameIn.placeholder = 'Enter your name';
      nameIn.readOnly = false;
      nameIn.disabled = false;
    }
    if (joinBtn) joinBtn.disabled = false;
    if (joinComputerBtn) joinComputerBtn.disabled = false;
    // allow user to choose number of computer opponents
    if (computerCountInput) {
      computerCountInput.disabled = false;
    }
    clearNameError(); // Check inside this function if errors persist

    const lobbyCard = $('lobby-form-card');
    if (lobbyCard) {
        lobbyCard.style.opacity = '1'; // Set opacity directly
    } else {
        console.error('[Debug Error] lobby-form-card is null in showLobbyForm (setting opacity)');
    }

    // Log final state
    console.log('[Debug] After changes:');
    if (modalOverlay) console.log(`  - modalOverlay classes: ${modalOverlay.className}`);
    if (lobbyContainer) console.log(`  - lobbyContainer classes: ${lobbyContainer.className}`);
    if (lobbyCard) console.log(`  - lobby-form-card opacity: ${lobbyCard.style.opacity}`);

    prevStarted = false; // Reset game start flag so showGameTable() can trigger again
  }

  function showWaitingState(roomId, playersLength, maxPlayers, playersList) {
    console.log('[Debug] showWaitingState called'); // Added log
    if (lobbyContainer) lobbyContainer.classList.remove('hidden');
    if (lobbyFormContent) lobbyFormContent.classList.add('hidden');
    if (waitingStateDiv) waitingStateDiv.classList.remove('hidden');

    const waitingHeading = $('waiting-heading');
    if (waitingHeading) {
      waitingHeading.textContent = `Room: ${roomId} (${playersLength}/${maxPlayers})`;
    }
    if (shareLinkMessage) {
      shareLinkMessage.textContent = `Share the link to invite others!`;
    }
    const url = new URL(window.location);
    url.searchParams.set('room', roomId);
    window.history.pushState({}, '', url);
    hideOverlay(); // Ensure overlay is hidden

    const startBtn = $('start-game-button');
    if (startBtn) {
      // Show start button once at least 2 players are in the room
      if (playersLength >= 2) {
        startBtn.classList.remove('hidden');
        startBtn.disabled = false;
      } else {
        startBtn.classList.add('hidden');
        startBtn.disabled = true;
      }
    }
  }

  function showGameTable() {
    console.log('[Debug] showGameTable called');
    if (lobbyContainer) lobbyContainer.classList.add('hidden');
    if (table) table.classList.remove('hidden'); // Ensure table is visible
    hideOverlay(); // Hide overlay when game starts
    closeModal(); // Ensure any open modals are closed
    // Reveal rewind/forward controls
    const rewindBtn = $('rewind-btn');
    if (rewindBtn) rewindBtn.classList.remove('hidden');
    const forwardBtn = $('forward-btn');
    if (forwardBtn) forwardBtn.classList.remove('hidden');
    // Reveal game log panel
    const gameLog = $('game-log');
    if (gameLog) gameLog.classList.remove('hidden');
  }

  /* ---------- Modal Handling ---------- */

  function openModal(modalElement) {
    console.log('[Debug] openModal called for:', modalElement ? modalElement.id : 'null'); // Re-added log
    if (!modalElement) return;
    closeModal();
    showOverlay(); // Show overlay ONLY for actual modals (like rules)
    modalElement.classList.remove('hidden');
    activeModal = modalElement;
    trapFocus(modalElement);
  }

  function closeModal() {
    console.log('[Debug] closeModal called for:', activeModal ? activeModal.id : 'null'); // Re-added log
    if (!activeModal) return;
    activeModal.classList.add('hidden');
    activeModal.removeEventListener('keydown', handleFocusTrap);
    activeModal = null;
    hideOverlay(); // Hide overlay if no other modal needs it
    if (document.activeElement && typeof document.activeElement.blur === 'function') {
      document.activeElement.blur();
    }
  }

  // Basic Focus Trap
  let focusableElements = null;
  let firstFocusableElement = null;
  let lastFocusableElement = null;

  function trapFocus(modalElement) {
    focusableElements = modalElement.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    if (!focusableElements.length) return;
    firstFocusableElement = focusableElements[0];
    lastFocusableElement = focusableElements[focusableElements.length - 1];

    // Focus the first element initially
    setTimeout(() => {
      firstFocusableElement.focus();
    }, 0);

    modalElement.addEventListener('keydown', handleFocusTrap);
  }

  function handleFocusTrap(e) {
    if (e.key !== 'Tab' || !activeModal) return;

    const currentFocusableElements = activeModal.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    if (!currentFocusableElements.length) return;
    const currentFirstFocusable = currentFocusableElements[0];
    const currentLastFocusable = currentFocusableElements[currentFocusableElements.length - 1];

    if (e.shiftKey) { // Shift + Tab
      if (document.activeElement === currentFirstFocusable) {
        currentLastFocusable.focus();
        e.preventDefault();
      }
    } else { // Tab
      if (document.activeElement === currentLastFocusable) {
        currentFirstFocusable.focus();
        e.preventDefault();
      }
    }
  }

  // Event listeners for rules modal
  if (rulesButton) {
    rulesButton.addEventListener('click', () => openModal(rulesModal));
  }
  if (rulesModalCloseButton) {
    rulesModalCloseButton.addEventListener('click', closeModal);
  }
  // Listener for back-to-lobby button
  const backToLobbyButton = $('back-to-lobby-button');
  if (backToLobbyButton) {
    backToLobbyButton.addEventListener('click', () => {
      // Reset user/session state
      myId = null;
      currentRoom = null;
      sessionStorage.removeItem('myId');
      sessionStorage.removeItem('currentRoom');
      // Remove room param from URL
      const url = new URL(window.location);
      url.searchParams.delete('room');
      window.history.pushState({}, '', url);
      // Hide game table and any game-over overlay
      const tableEl = document.getElementById('table');
      if (tableEl) tableEl.classList.add('hidden');
      const gameOver = document.getElementById('game-over-container');
      if (gameOver) gameOver.remove();
      // Show the lobby form
      showLobbyForm();
    });
  }

  // Close modal if overlay is clicked
  if (modalOverlay) {
    modalOverlay.addEventListener('click', closeModal);
  }

  // Close modal on Escape key
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && activeModal) {
      closeModal();
    }
  });

  /* ---------- Validation ---------- */
  function validateName() {
    if (nameIn && nameIn.readOnly && nameIn.value === 'Player 1') {
      clearNameError();
      return 'Player 1';
    }
    const n = nameIn.value.trim();
    if (!n) {
      if(nameIn) nameIn.classList.add('input-error');
      if(nameError) nameError.classList.remove('hidden');
      return false;
    }
    clearNameError();
    return n;
  }

  function clearNameError() {
    if (nameIn) nameIn.classList.remove('input-error');
    if (nameError) nameError.classList.add('hidden');
  }

  if (nameIn) {
    nameIn.value = '';
    nameIn.placeholder = 'Enter your name';
    nameIn.disabled = false;
    nameIn.readOnly = false;
  }

  /* ---------- Socket Event Handlers ---------- */
  socket.on('connect', () => {
    console.log('âœ… Socket connected');
    console.log('[Debug Connect] Checking sessionStorage...');
    const storedId = sessionStorage.getItem('myId');
    const storedRoom = sessionStorage.getItem('currentRoom');
    console.log(`[Debug Connect] storedId: ${storedId}, storedRoom: ${storedRoom}`);

    if (storedId && storedRoom) {
      console.log(`[Debug Connect] Attempting rejoin for room ${storedRoom} as ${storedId}`);
      socket.emit('rejoin', storedId, storedRoom);
    } else {
      console.log('[Debug Connect] No session found, preparing to show lobby.');
      myId = null;
      currentRoom = null;
      sessionStorage.removeItem('myId');
      sessionStorage.removeItem('currentRoom');
      console.log('[Debug Connect] Calling showLobbyForm()...');
      showLobbyForm(); // This should now run after DOM is ready
      console.log('[Debug Connect] ...showLobbyForm() called.');
    }
  });

  socket.on('connect_error', (err) => {
    console.error('âŒ Socket connection failed:', err.message);
    showError('Connection failed. Please refresh.');
  });

  socket.on('disconnect', (reason) => {
    console.log(`ðŸ”Œ Socket disconnected: ${reason}`);
    showError('Disconnected. Attempting to reconnect...');
  });

  // Auto-reload page when server signals public file change
  socket.on('reload', () => {
    console.log('ðŸ”„ Reloading page due to asset change');
    window.location.reload();
  });

  socket.on('joined', d => {
    myId = d.id;
    sessionStorage.setItem('myId', myId);
    console.log(`âœ… Joined/Rejoined as ${myId}`);
  });

  socket.on('gameRoom', roomId => {
    console.log(`ðŸšª Entered game room: ${roomId}`);
    currentRoom = roomId;
    sessionStorage.setItem('currentRoom', currentRoom);
  });

  socket.on('lobby', data => {
    console.log('ðŸ›‹ï¸ Lobby update:', data);
    const { players, maxPlayers, roomId } = data;
    currentRoom = roomId;
    sessionStorage.setItem('currentRoom', currentRoom);
    showWaitingState(roomId, players.length, maxPlayers);
  });

  // Track previous started state to prevent multiple showGameTable() calls
  let prevStarted = false;

  // Previous client-side CPU delay logic removed; rendering immedately on each state
  // Hide rewind/fwd until game starts
  const rewindBtn = $('rewind-btn');
  const forwardBtn = $('forward-btn');
  let stateHistory = [];
  let stateIndex = -1;

  socket.on('state', s => {
    console.log('[CLIENT] Received state event:', s);
    // Always render the state, regardless of animation or pileTransition
    renderGameState(s);

    // Track turn changes for debugging
    const prevState = stateHistory.length > 0 ? stateHistory[stateHistory.length - 1] : null;
    if (prevState && prevState.turn !== s.turn) {
      gameDebug.logTurnChange(prevState.turn, s.turn);
    }

    if (s.started && !prevStarted) showGameTable();
    prevStarted = s.started;

    if (s.started) {
      // Check if this is the first state update or if we need to delay the CPU's first move
      const isFirstState = stateHistory.length === 0;
      const isFirstMove = isFirstState && s.playPile && s.playPile.length === 1;
      
      // Track history and render state with possible delay
      if (isFirstMove && s.turn && s.turn !== myId && s.players.find(p => p.id === s.turn)?.isComputer) {
        // This is the CPU's first move after human played first card - add a delay
        console.log("[Debug] First CPU move detected - adding artificial delay");
        // Render the state without the CPU's turn first, so player sees their own card
        const initialState = JSON.parse(JSON.stringify(s));
        initialState.turn = myId; // Force turn to stay with human player temporarily
        stateHistory.push(initialState);
        stateIndex = stateHistory.length - 1;
        renderGameState(initialState);
        
        // After a delay, update with the real state (CPU's turn)
        setTimeout(() => {
          stateHistory.pop(); // Remove the temporary state
          stateHistory.push(JSON.parse(JSON.stringify(s))); // Add the real state
          stateIndex = stateHistory.length - 1;
          renderGameState(s);
          
          // Enable rewind/forward buttons
          if (rewindBtn) rewindBtn.disabled = stateIndex <= 0;
          if (forwardBtn) forwardBtn.disabled = stateIndex >= stateHistory.length - 1;
        }, 1500); // 1.5 second delay before showing CPU play
      } else {
        // Normal state update
        stateHistory.push(JSON.parse(JSON.stringify(s)));
        stateIndex = stateHistory.length - 1;
        renderGameState(s);
        // Enable rewind/forward buttons
        if (rewindBtn) rewindBtn.disabled = stateIndex <= 0;
        if (forwardBtn) forwardBtn.disabled = stateIndex >= stateHistory.length - 1;
      }
      
      // Process any queued special effects on the first state
      if (stateHistory.length === 1 && specialEffectsQueue.length > 0) {
        console.log("[Debug] First state detected with queued effects. Processing in 800ms...");
        setTimeout(() => processNextEffect(), 800);
      }
    }
    // Do not override waiting state here; lobby event controls showing the waiting UI
  });

  socket.on('gameOver', ({ winnerId, winnerName }) => {
    console.log(`[Debug] Game Over! Winner: ${winnerName} (${winnerId})`);
    showGameOverMessage(winnerId === myId, winnerName);
  });

  // Handle general notices/errors from the server
  socket.on('err', msg => {
    console.error(`âŒ Server Error: ${msg}`);
    
    // Check if this is an invalid play type of error that should show an icon
    const isInvalidPlay = msg.toLowerCase().includes('invalid play') || 
                          msg.toLowerCase().includes('must be higher') || 
                          msg.toLowerCase().includes('cannot play');
    
    // For invalid play errors, use the special card animation sequence
    if (isInvalidPlay) {
      // Disable play buttons during effect
      setPileTransition(true);
      
      // Get the discard pile card to animate on
      const discardImg = document.querySelector('.discard .card-img');
      if (discardImg) {
        // Add pulse animation to the card
        discardImg.classList.add('special-card-pulse');
        
        // After brief delay, show the icon
        setTimeout(() => {
          // Remove pulse effect
          discardImg.classList.remove('special-card-pulse');
          
          // Show the invalid play icon with full animation
          showCardEvent(null, 'invalid');
          
          // Deselect cards immediately for better feedback
          const selectedCards = document.querySelectorAll('.card-img.selected');
          selectedCards.forEach(img => {
            img.classList.remove('selected');
            const container = img.closest('.card-container');
            if (container) container.classList.remove('selected-container');
          });
          
          // Re-enable buttons after animation completes
          setTimeout(() => {
            setPileTransition(false);
          }, 1200);
        }, 800);
      } else {
        // Fallback if no discard pile is found
        showCardEvent(null, 'invalid');
        
        // Always deselect cards on invalid plays
        const selectedCards = document.querySelectorAll('.card-img.selected');
        selectedCards.forEach(img => {
          img.classList.remove('selected');
          const container = img.closest('.card-container');
          if (container) container.classList.remove('selected-container');
        });
        
        setPileTransition(false);
      }
      
      // Track this error in the debug system
      gameDebug.logEvent('ERROR', 'Invalid play', { message: msg });
    } else {
      // For other errors, just show the message
      gameDebug.logEvent('ERROR', 'Server error', { message: msg });
    }
    
    // Show toast notification for all errors
    showError(msg);

    // Handle "Game room no longer exists" error during rejoin
    if (msg.includes('Game room no longer exists')) {
      console.log('Handling \'Game room no longer exists\' error: Resetting state.');
      myId = null;
      currentRoom = null;
      sessionStorage.removeItem('myId');
      sessionStorage.removeItem('currentRoom');
      // Clear the room parameter from the URL
      const url = new URL(window.location);
      url.searchParams.delete('room');
      window.history.pushState({}, '', url);
      // Show the lobby form
      showLobbyForm();
    }
  });

  // Process special card effects with a standardized sequence
  socket.on('specialEffect', ({ value, type }) => {
    console.log(`[Debug] Special effect received: value=${value}, type=${type}`);
    
    // Standardize the type name to avoid inconsistencies
    // This ensures we always use the same effect type regardless of how the server sends it
    let standardizedType = type;
    
    // Map specific card values to their effect types
    if (!type && value) {
      if (value == 2) standardizedType = 'two';
      else if (value == 5) standardizedType = 'five';
      else if (value == 10) standardizedType = 'ten';
      else if (value == 4 && Array.isArray(value)) standardizedType = 'four'; // four of a kind
    }
    
    // Log both original and standardized values for debugging
    gameDebug.logSpecialEffect(value, standardizedType, null, null);
    
    // Queue the effect with standardized type
    specialEffectsQueue.push({ value, type: standardizedType });
    
    // If we're not already processing effects and the game has started, process the queue
    if (!processingEffects && stateHistory.length > 0) {
      processNextEffect();
    }
    // Note: If game hasn't started yet, the effect will be processed after the first render
  });

  // Process the next effect in the queue
  function processNextEffect() {
    if (specialEffectsQueue.length === 0) {
      processingEffects = false;
      return;
    }
    
    processingEffects = true;
    const effect = specialEffectsQueue.shift();
    console.log(`[Debug] Processing effect: ${effect.type}`);
    
    // Only block play/take for actual special cards, not for 'take' effect
    if (effect.type === 'invalid') {
      setPileTransition(true);
    }
    
    // Handle immediate-display effects (invalid play, take pile)
    if (effect.type === 'invalid' || effect.type === 'take') {
      showCardEvent(effect.value, effect.type);
      
      // Longer delay for these effects to ensure they're visible
      setTimeout(() => {
        if (effect.type === 'invalid') setPileTransition(false);
        gameDebug.logEffectPhase(effect.type, "completed", { value: effect.value });
        
        // Continue with next effect after a sufficient delay
        // Add a small buffer to ensure animations don't overlap
        setTimeout(processNextEffect, 800);
      }, 1500);
      return;
    }
    
    // Special card effect sequence
    const discardImg = document.querySelector('.discard .card-img');
    if (!discardImg) {
      console.error("[Debug] No discard image found for special effect");
      setPileTransition(false);
      gameDebug.logEffectPhase(effect.type, "failed", { reason: "No discard image found" });
      
      // Try again after a short delay if we're at game start
      if (stateHistory.length <= 1) {
        console.log("[Debug] Retrying effect after delay - likely initial Ten");
        setTimeout(() => {
          specialEffectsQueue.unshift(effect); // Put back at the front of the queue
          processNextEffect();
        }, 1000);
      } else {
        setTimeout(processNextEffect, 500);
      }
      return;
    }
    
    // Flag this card as a special card that's currently being shown
    discardImg.classList.add('current-special-card');
    
    // Step 1: Highlight the special card that was played (already on discard pile)
    // Add a subtle pulse animation to draw attention to the special card
    discardImg.classList.add('special-card-pulse');
    gameDebug.logEffectPhase(effect.type, "pulse-start");
    
    // Step 2: After showing the special card briefly, show the icon
    setTimeout(() => {
      // Hide the pulse effect but keep showing the card
      discardImg.classList.remove('special-card-pulse');
      
      // Show the special effect icon
      showCardEvent(effect.value, effect.type);
      gameDebug.logEffectPhase(effect.type, "icon-shown");
      
      // Log for debugging
      console.log(`[Debug] Special card effect shown: ${effect.type}`);
      
      // Step 3: After showing the icon, apply the card change if needed
      setTimeout(() => {
        // For card 5 (copy), add a small "copied" indicator
        if (effect.type === 'five' || effect.value == 5) {
          const copyIndicator = document.createElement('div');
          copyIndicator.className = 'copy-indicator';
          copyIndicator.textContent = 'Copied';
          copyIndicator.style.position = 'absolute';
          copyIndicator.style.bottom = '5px';
          copyIndicator.style.right = '5px';
          copyIndicator.style.background = 'rgba(0, 0, 0, 0.7)';
          copyIndicator.style.color = 'white';
          copyIndicator.style.padding = '2px 5px';
          copyIndicator.style.borderRadius = '3px';
          copyIndicator.style.fontSize = '10px';
          copyIndicator.style.fontWeight = 'bold';
          copyIndicator.style.zIndex = '150';
          copyIndicator.style.opacity = '0';
          copyIndicator.style.transition = 'opacity 0.5s';
          
          // Add to card parent
          const cardParent = discardImg.parentElement;
          if (cardParent) {
            cardParent.style.position = 'relative';
            cardParent.appendChild(copyIndicator);
            
            // Fade in
            setTimeout(() => {
              copyIndicator.style.opacity = '1';
              gameDebug.logEffectPhase(effect.type, "copy-indicator-shown");
              
              // Remove after a while
              setTimeout(() => {
                copyIndicator.style.opacity = '0';
                setTimeout(() => {
                  if (copyIndicator.parentNode === cardParent) {
                    copyIndicator.remove();
                  }
                }, 500);
              }, 2000);
            }, 100);
          }
        }
        
        // Step 4: Complete the effect sequence
        setTimeout(() => {
          // Remove special card flag
          discardImg.classList.remove('current-special-card');
          
          // Re-enable play buttons
          setPileTransition(false);
          console.log(`[Debug] Special card effect complete: ${effect.type}`);
          gameDebug.logEffectPhase(effect.type, "completed");
          
          // Wait longer between effects to ensure each is fully visible
          // Use a guaranteed minimum delay to prevent animations overlapping
          setTimeout(processNextEffect, 1000);
        }, 2000); // Final wait before allowing play - increased to ensure card remains visible
      }, 2000); // Wait after showing icon before finishing effect - increased to ensure card remains visible
    }, 1000); // Wait before showing icon - increased from 800ms
  }

  socket.on('log', ({ player, action, cards }) => {
    const logContainer = document.getElementById('log-container');
    if (!logContainer) return;
    const entry = document.createElement('div');
    entry.className = 'log-entry';
    entry.textContent = `${player} ${action} ${cards.map(c => `${c.value} of ${c.suit}`).join(', ')}`;
    entry.addEventListener('click', () => {
      const act = actionHistory[entry.dataset.logIndex || actionHistory.length - 1];
      if (act) {
        if (act.type === 'play') socket.emit('playCards', act.indexes);
        else if (act.type === 'take') socket.emit('takePile');
      }
    });
    entry.dataset.logIndex = actionHistory.length - 1;
    logContainer.appendChild(entry);
  });

  /* ---------- Event Listeners ---------- */
  // Unified Create / Join game
  const playSelected = playSelectedCards;

  const createJoinBtn = $('create-join');
  if (createJoinBtn) {
    createJoinBtn.onclick = () => {
      const name = validateName();
      if (!name) return;
      const totalPlayers = parseInt($('total-players').value, 10) || 2;
      const cpuCount = parseInt($('computer-count').value, 10) || 0;
      console.log(`Creating/joining game as ${name} with ${totalPlayers} total, ${cpuCount} CPUs`);
      socket.emit('join', name, totalPlayers, cpuCount, initialRoom);
      createJoinBtn.disabled = true;
    };
  }

  if (tutorialBtn) {
    tutorialBtn.onclick = () => {
      if (lobbyContainer) lobbyContainer.classList.add('hidden');
      injectTutorialGameState();
      startTutorial();
    };
  }

  // Manual start game button
  const startGameBtn = $('start-game-button');
  if (startGameBtn) {
    startGameBtn.addEventListener('click', () => {
      socket.emit('startGame');
      startGameBtn.disabled = true; // prevent double sends
    });
  }

  const takeBtn = $('take');
  if (takeBtn) {
    takeBtn.onclick = () => {
      actionHistory.push({ type: 'take' });
      clearError();
      
      // Just take the pile directly without showing the special effect
      // This is a voluntary take, not a forced take due to no valid moves
      gameDebug.logTakePileEvent(myId, false);
      socket.emit('takePile');
    };
  }

  // Rewind/forward controls
  if (rewindBtn) {
    rewindBtn.addEventListener('click', () => {
      if (stateIndex > 0) {
        stateIndex--;
        renderGameState(stateHistory[stateIndex]);
        forwardBtn.disabled = false;
        rewindBtn.disabled = stateIndex <= 0;
      }
    });
  }
  if (forwardBtn) {
    forwardBtn.addEventListener('click', () => {
      if (stateIndex < stateHistory.length - 1) {
        stateIndex++;
        renderGameState(stateHistory[stateIndex]);
        rewindBtn.disabled = false;
        forwardBtn.disabled = stateIndex >= stateHistory.length - 1;
      }
    });
  }

  // Inject a fake game state for tutorial mode
  function injectTutorialGameState() {
    // Simulate a real game start: 3 hand, 3 up, 3 down for player and opponent
    const tutorialState = {
      deckCount: 40,
      playPile: [{ value: 4, suit: 'hearts' }],
      discardCount: 0,
      turn: 'tutorial-player',
      players: [
        {
          id: 'tutorial-player',
          name: 'You',
          isComputer: false,
          disconnected: false,
          hand: [
            { value: 7, suit: 'diamonds' },
            { value: 2, suit: 'spades' },
            { value: 9, suit: 'clubs' }
          ],
          handCount: 3,
          up: [
            { value: 5, suit: 'clubs' },
            { value: 10, suit: 'hearts' },
            { value: 8, suit: 'spades' }
          ],
          down: [
            { back: true },
            { back: true },
            { back: true }
          ],
          downCount: 3
        },
        {
          id: 'tutorial-opponent',
          name: 'CPU',
          isComputer: true,
          disconnected: false,
          hand: [],
          handCount: 3,
          up: [
            { value: 6, suit: 'hearts' },
            { value: 3, suit: 'spades' },
            { value: 'K', suit: 'clubs' }
          ],
          down: [
            { back: true },
            { back: true },
            { back: true }
          ],
          downCount: 3
        }
      ]
    };
    myId = 'tutorial-player';
    renderGameState(tutorialState);
  }

  // --- Tutorial Logic ---
  const tutorialSteps = [
    {
      message: 'Welcome to Top That! Let\'s learn the basics. Click Next to continue.',
      highlight: null,
      restrict: null,
      expect: null
    },
    {
      message: 'This is your hand. Play any card higher than the top card of the discard pile (highlighted).',
      highlight: 'hand',
      restrict: 'hand',
      expect: [0, 2] // allow 7 or 9 (indexes in hand)
    },
    {
      message: 'Try to play a 2. It resets the pile and lets you play anything next!',
      highlight: 'special2',
      restrict: '2',
      expect: [1] // only index 1 (the 2)
    },
    {
      message: 'Try to play a 10. It burns the pile!',
      highlight: null,
      restrict: null,
      expect: null // up card, will allow in next step
    },
    {
      message: 'Try to play a 5. It copies the previous card\'s value!',
      highlight: null,
      restrict: null,
      expect: null // up card, will allow in next step
    },
    {
      message: 'Great job! You\'ve learned the basics. Play a full game to master the rest!',
      highlight: null,
      restrict: null,
      expect: null
    }
  ];
  let tutorialStep = 0;
  let tutorialActive = false;

  function startTutorial() {
    tutorialActive = true;
    tutorialStep = 0;
    showTutorialStep();
  }

  function showTutorialStep() {
    showTutorialBanner(tutorialSteps[tutorialStep].message, tutorialStep > 0, tutorialStep < tutorialSteps.length - 1);
    highlightTutorialCards(tutorialSteps[tutorialStep].highlight);
  }

  function showTutorialBanner(msg, showBack, showNext) {
    let banner = document.getElementById('tutorial-banner');
    if (!banner) {
      banner = document.createElement('div');
      banner.id = 'tutorial-banner';
      banner.className = 'banner';
      banner.style.position = 'fixed';
      banner.style.top = '90px';
      banner.style.left = '50%';
      banner.style.transform = 'translateX(-50%)';
      banner.style.zIndex = 2000;
      banner.style.background = '#ffd36b';
      banner.style.color = '#222';
      banner.style.fontWeight = 'bold';
      banner.style.fontSize = '1.2rem';
      banner.style.padding = '1rem 2rem';
      banner.style.borderRadius = '10px';
      document.body.appendChild(banner);
    }
    banner.innerHTML = '';
    if (showBack) {
      const backBtn = document.createElement('button');
      backBtn.textContent = 'Back';
      backBtn.className = 'btn btn-tertiary';
      backBtn.style.marginRight = '1rem';
      backBtn.onclick = () => {
        tutorialStep = Math.max(0, tutorialStep - 1);
        showTutorialStep();
      };
      banner.appendChild(backBtn);
    }
    const msgSpan = document.createElement('span');
    msgSpan.textContent = msg;
    banner.appendChild(msgSpan);
    if (showNext) {
      const nextBtn = document.createElement('button');
      nextBtn.textContent = 'Next';
      nextBtn.className = 'btn btn-primary';
      nextBtn.style.marginLeft = '1rem';
      nextBtn.onclick = () => {
        tutorialStep = Math.min(tutorialSteps.length - 1, tutorialStep + 1);
        showTutorialStep();
      };
      banner.appendChild(nextBtn);
    }
  }

  function highlightTutorialCards(type) {
    // Remove previous highlights
    document.querySelectorAll('.tutorial-highlight').forEach(el => el.classList.remove('tutorial-highlight'));
    if (!type) return;
    if (type === 'hand') {
      document.querySelectorAll('#my-hand .card-img').forEach(el => el.classList.add('tutorial-highlight'));
    }
    // Special card highlights (2, 5, 10)
    if (type === 'special2') {
      document.querySelectorAll('#my-hand .card-img').forEach(el => {
        if (el.src.includes('/2')) el.classList.add('tutorial-highlight');
      });
    }
    if (type === 'special10') {
      document.querySelectorAll('#my-hand .card-img').forEach(el => {
        if (el.src.includes('/0')) el.classList.add('tutorial-highlight');
      });
    }
    if (type === 'special5') {
      document.querySelectorAll('#my-hand .card-img').forEach(el => {
        if (el.src.includes('/5')) el.classList.add('tutorial-highlight');
      });
    }
  }

  function showTutorialBanner() {
    let banner = document.getElementById('tutorial-banner');
    if (!banner) {
      banner = document.createElement('div');
      banner.id = 'tutorial-banner';
      banner.className = 'banner';
      banner.style.position = 'fixed';
      banner.style.top = '90px';
      banner.style.left = '50%';
      banner.style.transform = 'translateX(-50%)';
      banner.style.zIndex = 2000;
      banner.style.background = '#ffd36b';
      banner.style.color = '#222';
      banner.style.fontWeight = 'bold';
      banner.style.fontSize = '1.2rem';
      banner.style.padding = '1rem 2rem';
      banner.style.borderRadius = '10px';
      banner.textContent = 'Tutorial Mode: This is where your interactive tutorial will begin!';
      document.body.appendChild(banner);
    } else {
      banner.textContent = 'Tutorial Mode: This is where your interactive tutorial will begin!';
      banner.classList.remove('hidden');
    }
  }

  function snapCard(cardElement) {
    if (!cardElement) return;
    cardElement.classList.remove('snap-anim');
    // Force reflow to restart animation
    void cardElement.offsetWidth;
    cardElement.classList.add('snap-anim');
    setTimeout(() => cardElement.classList.remove('snap-anim'), 300);
  }

  function playSelectedCards() {
    if (pileTransition) return;

    const selectedCards = document.querySelectorAll('.card-img.selected');
    if (selectedCards.length === 0) return;

    const indexes = Array.from(selectedCards).map(img => parseInt(img.dataset.idx));
    console.log('Debug playSelectedCards:', { indexes, isHandPlay: indexes.every(idx => idx < 1000), isUpPlay: indexes.every(idx => idx >= 1000 && idx < 2000), isDownPlay: indexes.every(idx => idx >= 2000) });

    const isHandPlay = indexes.every(idx => idx < 1000);
    const isUpPlay = indexes.every(idx => idx >= 1000 && idx < 2000);
    const isDownPlay = indexes.every(idx => idx >= 2000);

    if (!(isHandPlay || isUpPlay || isDownPlay)) {
      showError("You can only play cards from one area (Hand, Up, or Down) at a time.");
      selectedCards.forEach(img => {
        img.classList.remove('selected');
        const cont = img.closest('.card-container');
        if (cont) cont.classList.remove('selected-container');
      });
      return;
    }
    
    socket.emit('playCards', indexes);
  }
  window.playSelectedCards = playSelectedCards;

  if (copyLinkBtn) {
    copyLinkBtn.onclick = () => {
      const url = window.location.href;
      navigator.clipboard.writeText(url)
        .then(() => {
          const originalText = copyLinkBtn.textContent;
          copyLinkBtn.textContent = 'Copied!';
          copyLinkBtn.disabled = true;
          setTimeout(() => {
            copyLinkBtn.textContent = originalText;
            copyLinkBtn.disabled = false;
          }, 1500);
        })
        .catch(err => {
          console.error('Failed to copy link: ', err);
          if(shareLinkMessage) shareLinkMessage.textContent = 'Could not copy link automatically.'; // Added null check
        });
    };
  }

  /* Remove Ctrl+R listener */
  /* document.addEventListener('keydown', e => {
    if (e.key === 'r' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      console.log('ðŸ›‘ Sending adminReset');
      socket.emit('adminReset');
      myId = null;
      currentRoom = null;
      sessionStorage.removeItem('myId');
      sessionStorage.removeItem('currentRoom');
      window.history.pushState({}, '', window.location.pathname);
      showLobbyForm();
    }
  }); */

  /* ---------- Helper Functions ---------- */
  function setPileTransition(active) {
    pileTransition = active;
    const playBtn = document.getElementById('play');
    if (playBtn) playBtn.disabled = active;
  }

  // Overlay special card symbol on top of discard pile card with improved animation
  function showCardEvent(cardValue, type) {
    let discardImg = document.querySelector('.discard .card-img');
    // If the discard pile is empty, retry after a short delay (up to 5 times)
    let retries = 0;
    function tryRunEffect() {
      discardImg = document.querySelector('.discard .card-img');
      if (!discardImg && retries < 5) {
        retries++;
        setTimeout(tryRunEffect, 100);
        return;
      }
      if (!discardImg) return; // Give up if still not found
      function runEffect() {
        // Remove any existing icon
        const prev = discardImg.parentElement.querySelector('.special-icon');
        if (prev) prev.remove();
        
        // Create an image for the special effect
        const icon = document.createElement('img');
        icon.className = 'special-icon';
        
        // Choose image based on effect using loose equality for consistent checks
        let src = '';
        if (type === 'two' || cardValue == 2) src = 'Reset-icon.png';
        else if (type === 'five' || cardValue == 5) src = 'Copy-icon.png';
        else if (type === 'ten' || cardValue == 10 || type === 'four') src = 'Burn-icon.png';
        else if (type === 'invalid') src = 'Invalid play-icon.png';
        else if (type === 'take') src = 'Take pile-icon.png';
        else if (type === 'regular') {
          // No outline or glow, just return
          return;
        }
        
        // Debug check for icon path
        console.log(`[DEBUG] Using icon: ${src}`);
        
        icon.src = src;
        icon.onerror = () => {
          console.error(`[ERROR] Failed to load icon: ${src}`);
          // Fallback for missing image
          icon.style.background = 'rgba(255,255,255,0.7)';
          icon.style.borderRadius = '50%';
          icon.style.display = 'flex';
          icon.style.justifyContent = 'center';
          icon.style.alignItems = 'center';
          
          // Add text as fallback
          const fallbackText = document.createElement('div');
          fallbackText.textContent = type === 'take' ? 'TAKE' : 
                                    type === 'two' ? 'RESET' :
                                    type === 'five' ? 'COPY' :
                                    type === 'ten' ? 'BURN' : 'X';
          fallbackText.style.color = '#000';
          fallbackText.style.fontWeight = 'bold';
          icon.appendChild(fallbackText);
        };
        
        // Position and size with improved styling
        icon.style.position = 'absolute';
        icon.style.top = '50%';
        icon.style.left = '50%';
        icon.style.transform = 'translate(-50%, -50%)';
        icon.style.width = '90px'; // Slightly bigger for better visibility
        icon.style.height = '90px';
        icon.style.zIndex = '100'; // Ensure icon is above the card but below other UI elements
        icon.style.background = 'none';
        icon.style.backgroundColor = 'transparent';
        icon.style.pointerEvents = 'none';
        icon.style.filter = 'drop-shadow(0 0 12px rgba(255, 255, 255, 0.9))'; // Enhanced glow
        
        // Use CSS animation for smoother performance
        icon.style.animation = 'iconPulse 1.5s ease-in-out'; // Longer animation
        
        // Ensure parent is positioned for absolute positioning to work
        discardImg.parentElement.style.position = 'relative';
        discardImg.parentElement.appendChild(icon);
        
        // Highlight discard pile
        const discardPile = discardImg.closest('.discard');
        if (discardPile) {
          discardPile.classList.add('ring-pulse');
          setTimeout(() => discardPile.classList.remove('ring-pulse'), 1000); // Longer pulse effect
        }
        
        // Remove after delay with fade out for smoother transition
        setTimeout(() => {
          icon.style.transition = 'opacity 0.5s ease, transform 0.5s ease'; // Slower fade
          icon.style.opacity = '0';
          icon.style.transform = 'translate(-50%, -50%) scale(0.8)';
          setTimeout(() => icon.remove(), 500); // Wait longer before removing
        }, 1800); // Show for 1.8 seconds, increased from 1 second
      }
      
      if (!discardImg.complete) {
        discardImg.addEventListener('load', runEffect, { once: true });
      } else {
        runEffect();
      }
    }
    tryRunEffect();
  }

  function showIcon(iconSrc) {
    const center = document.getElementById('center');
    if (!center) return;
    const img = document.createElement('img');
    img.src = iconSrc;
    img.className = 'special-icon';
    img.style.width = '100px';
    img.style.height = '100px';
    img.style.position = 'absolute';
    img.style.top = '50%';
    img.style.left = '50%';
    img.style.transform = 'translateX(-50%)';
    img.style.pointerEvents = 'none';
    center.appendChild(img);
    setTimeout(() => img.remove(), 2000);
  }

  function showError(msg) {
    console.log('[Debug] showError:', msg);
    const container = document.getElementById('toast-container');
    if (!container) return;
    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.textContent = msg;
    container.appendChild(toast);
    // Auto-remove after 2s (uniform)
    setTimeout(() => toast.remove(), 2000);
  }

  function clearError() {
    const errorBanner = document.getElementById('error-banner');
    if (errorBanner) errorBanner.classList.add('hidden');
  }

  function code(c) {
    if (!c || typeof c.value === 'undefined' || c.value === null) return '';
    const v = c.value === 10 ? '0' : String(c.value).toUpperCase() === 'A' ? 'ace' : String(c.value).toUpperCase();
    const s = { hearts: 'H', diamonds: 'D', clubs: 'C', spades: 'S' }[c.suit];
    if (!s) return '';
    if (v === 'ace') return `A${s}`;
    return v + s;
  }

  function cardImg(card, sel = false, onCardLoad) {
    const container = document.createElement('div');
    container.classList.add('card-container');
    const img = new Image();
    img.className = 'card-img';
    img.style.visibility = 'hidden';  // Hide alt text until image loads
    img.src = card.back
      ? 'https://deckofcardsapi.com/static/img/back.png'
      : `https://deckofcardsapi.com/static/img/${code(card)}.png`;
    img.alt = card.back ? 'Card back' : `${card.value} of ${card.suit}`;
    img.onload = () => {
      img.style.visibility = 'visible';
      if (typeof onCardLoad === 'function') onCardLoad(img);
    };
    
    if (sel) {
      img.classList.add('selectable');
      img.style.cursor = 'pointer';
      img.style.touchAction = 'manipulation'; // Improves touch responsiveness
      
      // Track click/touch timing for better interaction handling
      let lastInteractionTime = 0;
      const DOUBLE_INTERACTION_THRESHOLD = 300; // ms
      
      // Combined function for both click and touch
      const handleInteraction = (e) => {
        const now = Date.now();
        const timeSinceLastInteraction = now - lastInteractionTime;
        
        // Handle double-click/tap
        if (timeSinceLastInteraction < DOUBLE_INTERACTION_THRESHOLD) {
          // Double interaction - select and play the card
          if (!img.classList.contains('selected')) {
            img.classList.add('selected');
            container.classList.add('selected-container');
          }
          
          // Prevent event propagation
          e.stopPropagation();
          e.preventDefault();
          
          // Visual feedback
          snapCard(img);
          
          // Play immediately
          playSelectedCards();
          
          // Reset tracking
          lastInteractionTime = 0;
        } else {
          // Single interaction - toggle selection
          const isSelected = img.classList.toggle('selected');
          container.classList.toggle('selected-container', isSelected);
          lastInteractionTime = now;
        }
      };
      
      // Mouse events
      img.addEventListener('click', handleInteraction);
      
      // Touch events for mobile
      img.addEventListener('touchstart', (e) => {
        // Prevent scrolling when interacting with cards
        if (e.cancelable) e.preventDefault();
      }, { passive: false });
      
      img.addEventListener('touchend', (e) => {
        // Only process if this is a tap (not a scroll or multi-touch)
        if (e.changedTouches && e.changedTouches.length === 1) {
          handleInteraction(e);
        }
      });
    }
    
    container.appendChild(img);
    return container;
  }

  function renderSection(panel, title, content) {
    const section = document.createElement('div');
    section.className = 'game-section';
    const titleDiv = document.createElement('div');
    titleDiv.className = 'section-title';
    titleDiv.textContent = title;
    section.appendChild(titleDiv);
    section.appendChild(content);
    panel.appendChild(section);
    return section;
  }

  function showTookPileBanner(panel) {
    const oldBanner = panel.querySelector('.took-pile-banner');
    if (oldBanner) oldBanner.remove();
    const banner = document.createElement('div');
    banner.className = 'took-pile-banner';
    banner.textContent = 'Took the pile!';
    panel.insertBefore(banner, panel.firstChild);
    setTimeout(() => {
      banner.remove();
    }, 2000);
  }

  function createCenterPiles(state) {
    const center = document.getElementById('center');
    if (!center) return;

    // Clear existing content except for event/error banners
    const eventBanner = document.getElementById('event-banner');
    const errorBanner = document.getElementById('error-banner');
    center.innerHTML = '';
    if (eventBanner) center.appendChild(eventBanner);
    if (errorBanner) center.appendChild(errorBanner);

    // Create center area to hold the piles
    const centerArea = document.createElement('div');
    centerArea.className = 'center-area';

    // Create wrapper for piles
    const pilesWrapper = document.createElement('div');
    pilesWrapper.className = 'center-piles-wrapper';

    // Create deck pile
    const deckContainer = document.createElement('div');
    deckContainer.className = 'center-pile-container';
    const deckLabel = document.createElement('div');
    deckLabel.textContent = `Deck (${state.deckCount})`;
    deckLabel.className = 'pile-label';
    const deckPile = document.createElement('div');
    deckPile.className = 'deck pile';
    if (state.deckCount > 0) {
      const deckCard = cardImg({ back: true }, false);
      deckPile.appendChild(deckCard);
    }
    deckContainer.appendChild(deckLabel);
    deckContainer.appendChild(deckPile);

    // Create discard pile
    const discardContainer = document.createElement('div');
    discardContainer.className = 'center-pile-container';
    const discardLabel = document.createElement('div');
    discardLabel.className = 'pile-label';
    discardLabel.textContent = `Discard (${state.discardCount || 0})`;
    const discardPile = document.createElement('div');
    discardPile.className = 'discard pile';
    if (state.playPile && state.playPile.length > 0) {
      const topCard = state.playPile[state.playPile.length - 1];
      const discardCard = cardImg(topCard, false);
      discardPile.appendChild(discardCard);
    }
    discardContainer.appendChild(discardLabel);
    discardContainer.appendChild(discardPile);

    // Add piles to wrapper
    pilesWrapper.appendChild(deckContainer);
    pilesWrapper.appendChild(discardContainer);

    // Add wrapper to center area
    centerArea.appendChild(pilesWrapper);
    
    // Add center area to center
    center.appendChild(centerArea);
  }

  function renderGameState(s) {
    console.log('[CLIENT] renderGameState called. State:', s);
    // Card table layout: clear all slots
    const slotTop = document.querySelector('.table-slot-top');
    const slotBottom = document.querySelector('.table-slot-bottom');
    const slotLeft = document.querySelector('.table-slot-left');
    const slotRight = document.querySelector('.table-slot-right');
    const slotCenter = document.querySelector('.table-slot-center');
    if (slotTop) slotTop.innerHTML = '';
    if (slotBottom) slotBottom.innerHTML = '';
    if (slotLeft) slotLeft.innerHTML = '';
    if (slotRight) slotRight.innerHTML = '';

    // Remove any previous active highlights
    document.querySelectorAll('.player-area.active').forEach(el => el.classList.remove('active'));

    // --- Robust seat assignment for 2-4 players ---
    const meIdx = s.players.findIndex(p => p.id === myId);
    const playerCount = s.players.length;
    // Map seat index to slot name
    function seatFor(idx) {
      if (playerCount === 2) return idx === meIdx ? 'bottom' : 'top';
      if (playerCount === 3) {
        if (idx === meIdx) return 'bottom';
        if ((idx - meIdx + playerCount) % playerCount === 1) return 'left';
        return 'right'; // Use right instead of top for 3 players
      }
      if (playerCount === 4) {
        if (idx === meIdx) return 'bottom';
        if ((idx - meIdx + playerCount) % playerCount === 1) return 'left';
        if ((idx - meIdx + playerCount) % playerCount === 2) return 'top';
        return 'right';
      }
      return 'bottom';
    }

    // --- Render all players in correct slots ---
    s.players.forEach((p, idx) => {
      const seat = seatFor(idx);
      let panel = document.createElement('div');
      panel.className = 'player-area' + (p.isComputer ? ' computer-player' : '');
      panel.dataset.playerId = p.id;
      if (seat === 'bottom' && p.id === myId) panel.id = 'my-area';
      if (p.isComputer) panel.classList.add('computer-player');
      if (p.disconnected) panel.classList.add('disconnected');
      if (p.id === s.turn) panel.classList.add('active');
      // All player panels: vertical stacking (banner, hand, up/down)
      panel.style.display = 'flex';
      panel.style.flexDirection = 'column';
      panel.style.alignItems = 'center';
      // Add rotation classes for left/right CPUs
      if (seat === 'left') panel.classList.add('rotate-right');
      if (seat === 'right') panel.classList.add('rotate-left');
      // Name header (banner)
      const nameHeader = document.createElement('div');
      nameHeader.className = 'player-name-header ' + (p.isComputer ? 'player-cpu' : 'player-human');
      nameHeader.innerHTML = `<span class="player-name-text">${p.name}${p.disconnected ? " <span class='player-role'>(Disconnected)</span>" : ''}</span>`;
      panel.appendChild(nameHeader);
      // Hand row
      const handRow = document.createElement('div');
      if (p.id === myId) handRow.id = 'my-hand';
      handRow.className = p.id === myId ? 'hand' : 'opp-hand';
      if (p.id === myId && p.hand && p.hand.length > 0) {
        // Render hand cards and tag each img with its index for play detection
        for (let i = 0; i < p.hand.length; i++) {
          const card = p.hand[i];
          const canInteract = s.turn === myId;
          const container = cardImg(card, canInteract);
          const imgEl = container.querySelector('.card-img');
          if (imgEl) imgEl.dataset.idx = i;
          handRow.appendChild(container);
        }
      } else if (p.handCount > 0) {
        // Show placeholder backs for opponents (human or CPU)
        // Limit CPU display to a maximum of 3 cards even if they have more
        const displayCount = Math.min(p.handCount, 3);
        for (let i = 0; i < displayCount; i++) {
          const el = document.createElement('div');
          el.className = 'card-placeholder';
          const cardEl = cardImg({ back: true }, false);
          el.appendChild(cardEl);
          handRow.appendChild(el);
        }
      }
      
      // Show the actual card count in the section label for opponents
      renderSection(panel, `Hand${p.id === myId ? '' : ' (' + p.handCount + ')'}`, handRow);
      
      // Buttons for human player (only in bottom slot)
      if (p.id === myId && seat === 'bottom') {
        let btnContainer = document.createElement('div');
        btnContainer.className = 'button-container';
        btnContainer.id = 'dynamic-btn-container';
        const playBtnDyn = document.createElement('button');
        playBtnDyn.id = 'play';
        playBtnDyn.textContent = 'Play';
        playBtnDyn.onclick = playSelectedCards;
        playBtnDyn.className = 'btn btn-primary';
        const takeBtnDyn = document.createElement('button');
        takeBtnDyn.id = 'take';
        takeBtnDyn.textContent = 'Take';
        takeBtnDyn.onclick = () => {
          clearError();
          gameDebug.logTakePileEvent(myId, false);
          socket.emit('takePile');
        };
        takeBtnDyn.className = 'btn btn-secondary';
        btnContainer.appendChild(playBtnDyn);
        btnContainer.appendChild(takeBtnDyn);
        // Enable/disable based on turn
        playBtnDyn.disabled = !s.turn || s.turn !== myId || pileTransition;
        // Take button is only disabled if it's not your turn
        takeBtnDyn.disabled = !s.turn || s.turn !== myId ? true : false;
        btnContainer.style.display = 'flex';
        panel.appendChild(btnContainer);
      }
      // Up/Down stacks
      const stackRow = document.createElement('div');
      stackRow.className = 'stack-row';
      if (p.up && p.up.length > 0) {
        p.up.forEach((c, i) => {
          const col = document.createElement('div');
          col.className = 'stack';
          const downCard = cardImg({ back: true }, false);
          const downCardImg = downCard.querySelector('.card-img');
          if (downCardImg) downCardImg.classList.add('down-card');
          const upCard = cardImg(c, p.id === myId && s.turn === myId && p.hand.length === 0 && !pileTransition);
          const upCardImg = upCard.querySelector('.card-img');
          if (upCardImg) {
            upCardImg.classList.add('up-card');
            if (p.id === myId) upCardImg.dataset.idx = i + 1000;
          }
          col.append(downCard, upCard);
          if (p.id === myId && s.turn === myId && p.hand.length === 0 && !pileTransition) {
            col.classList.add('playable-stack'); // mark stack as playable
          }
          stackRow.appendChild(col);
        });
      } else if (p.downCount && p.downCount > 0) {
        for (let i = 0; i < p.downCount; i++) {
          const col = document.createElement('div');
          col.className = 'stack';
          const downCard = cardImg({ back: true }, p.id === myId && s.turn === myId && (!p.up || p.up.length === 0) && i === 0 && !pileTransition);
          const downCardImg = downCard.querySelector('.card-img');
          if (downCardImg) {
            downCardImg.classList.add('down-card');
            if (p.id === myId) downCardImg.dataset.idx = i + 2000;
          }
          col.appendChild(downCard);
          if (p.id === myId && s.turn === myId && (!p.up || p.up.length === 0) && i === 0 && !pileTransition) {
            col.classList.add('playable-stack'); // mark stack as playable
          }
          stackRow.appendChild(col);
        }
      }
      renderSection(panel, 'Up / Down', stackRow);
      // Place panel in correct slot
      if (seat === 'bottom' && slotBottom) slotBottom.appendChild(panel);
      else if (seat === 'top' && slotTop) slotTop.appendChild(panel);
      else if (seat === 'left' && slotLeft) slotLeft.appendChild(panel);
      else if (seat === 'right' && slotRight) slotRight.appendChild(panel);
    });

    // Create center piles AFTER players are rendered
    createCenterPiles(s);
    
    // Process any queued special effects after rendering
    setTimeout(() => processSpecialEffectsQueue(), 200);
  }

  // Process any queued special effects
  function processSpecialEffectsQueue() {
    if (specialEffectsQueue.length > 0 && !processingEffects) {
      processNextEffect();
    }
  }

  function showGameOverMessage(didIWin, winnerName) {
    // Create or find a container for the game over message
    let gameOverContainer = document.createElement('div');
    gameOverContainer.id = 'game-over-container';
    gameOverContainer.style.position = 'fixed';
    gameOverContainer.style.top = '0';
    gameOverContainer.style.left = '0';
    gameOverContainer.style.width = '100%';
    gameOverContainer.style.height = '100%';
    gameOverContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.75)';
    gameOverContainer.style.display = 'flex';
    gameOverContainer.style.flexDirection = 'column';
    gameOverContainer.style.justifyContent = 'center';
    gameOverContainer.style.alignItems = 'center';
    gameOverContainer.style.zIndex = '3000'; // Ensure it's on top
    gameOverContainer.style.color = 'white';
    gameOverContainer.style.textAlign = 'center';
    document.body.appendChild(gameOverContainer);

    gameOverContainer.innerHTML = `
      <img src="/generated-icon.png" alt="Top That Crown" style="width:100px;height:100px;margin-bottom:20px;" />
      <h1 style="font-size: 3em; margin-bottom: 10px;">Game Over!</h1>
      <p style="font-size: 1.5em; margin-bottom: 30px;">
        ${didIWin ? 'ðŸŽ‰ You win! ðŸŽ‰' : `${winnerName} wins!`}
      </p>
      <button id="play-again-btn" class="btn btn-primary" style="font-size: 1.2em; padding: 10px 20px;">Play Again</button>
    `;

    // Add event listener for the play again button
    const playAgainBtn = document.getElementById('play-again-btn');
    if (playAgainBtn) {
      playAgainBtn.onclick = () => {
        // Reload the page to go back to the lobby
        window.location.reload();
      };
    }

    gameOverContainer.classList.remove('hidden');
  }

}); // End of DOMContentLoaded listener
</file>

</files>
