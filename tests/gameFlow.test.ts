import {
  createMockSocket,
  createMockIO,
  MockSocket,
  MockIO,
} from './testUtils.js';
import GameController from '../controllers/GameController.js';
import GameState from '../models/GameState.js';
import {
  JOINED,
  LOBBY_STATE_UPDATE,
  STATE_UPDATE,
  NEXT_TURN,
  PLAYER_READY,
  ANIMATIONS_COMPLETE,
  PLAY_CARD,
  GAME_OVER,
  PILE_PICKED_UP,
  PICK_UP_PILE,
  ERROR,
} from '../src/shared/events.ts';
import { JoinGamePayload } from '../src/shared/types.js';

// --- Type Definitions for Mocks ---
// Remove local MockSocket, MockIO, and related mock factory code

// --- Mock Implementations ---
let globalMockSocket: MockSocket;
let topLevelEmitMock: jest.Mock;
let mockIo: MockIO;

// Add a type for state payloads emitted in tests
interface StatePayload {
  players: any[];
  currentPlayerId: string;
  started: boolean;
}

describe('Game Flow - Single Player vs CPU (manual start)', () => {
  let gameController: GameController;

  beforeEach(() => {
    topLevelEmitMock = jest.fn();
    mockIo = createMockIO(topLevelEmitMock);

    globalMockSocket = createMockSocket('socket-id-1', topLevelEmitMock);

    if (mockIo.sockets && mockIo.sockets.sockets) {
      mockIo.sockets.sockets.clear();
      mockIo.sockets.sockets.set(globalMockSocket.id, globalMockSocket);
    }

    mockIo.on.mockClear();
    mockIo.to.mockClear();
    // Pass a dummy roomId for tests (required by GameController constructor)
    gameController = new GameController(mockIo as any, 'test-room');
  });

  test('Player joins and host starts game with 1 CPU, initial state is broadcast', () => {
    const joinPayload: JoinGamePayload = {
      playerName: 'Player1',
      numHumans: 1,
      numCPUs: 1,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(
      globalMockSocket,
      joinPayload
    );

    // Game should not auto-start for human vs CPU
    // expect(gameController['gameState'].started).toBe(false);
    (gameController['handleStartGame'] as Function)({
      computerCount: 1,
      socket: globalMockSocket,
    });

    expect(gameController['gameState'].started).toBe(true);
    // Player IDs are now generated by the server, so check by name
    const player = Array.from(gameController['players'].values()).find(
      (p) => p.name === joinPayload.playerName
    );
    expect(player).toBeDefined();
    expect(gameController['players'].has('COMPUTER_1')).toBe(true);

    // Check that a CPU player was added (robust to ID changes)
    const cpuPlayer = Array.from(gameController['players'].values()).find(
      (p) => p.isComputer
    );
    expect(cpuPlayer).toBeDefined();
    // After start, CPUs should be present and game should be started
    expect(gameController['gameState'].started).toBe(true);
    expect(cpuPlayer).toBeDefined();

    // Find the state update with started: true
    const stateUpdateAfterStart = topLevelEmitMock.mock.calls.find(
      (call) => call[0] === STATE_UPDATE && (call[1] as any)?.started === true
    );
    expect(stateUpdateAfterStart).toBeDefined();
    const emittedState = stateUpdateAfterStart![1] as any;
    expect(emittedState.players.length).toBe(2);
    // The first player is the human
    expect(
      emittedState.players.some((p: any) => p.name === joinPayload.playerName)
    ).toBe(true);

    // Check that NEXT_TURN was emitted for the human
    const nextTurnArgs = topLevelEmitMock.mock.calls.find(
      (call) => call[0] === NEXT_TURN
    );
    expect(nextTurnArgs).toBeDefined();
    // Check hands were dealt
    const playerInstance = Array.from(gameController['players'].values()).find(
      (p) => p.name === joinPayload.playerName
    );
    // Use the found CPU player for hand check
    expect(playerInstance && playerInstance.hand.length).toBe(3);
    expect(cpuPlayer && cpuPlayer.hand.length).toBe(3);
    expect(gameController['gameState'].deck!.length).toBe(52 - 2 * 9 - 1);
  });
});

describe('Game Flow - Lobby with Extra Human', () => {
  let gameController: GameController;

  beforeEach(() => {
    topLevelEmitMock = jest.fn();
    mockIo = createMockIO(topLevelEmitMock);

    globalMockSocket = createMockSocket('socket-lobby', topLevelEmitMock);

    if (mockIo.sockets && mockIo.sockets.sockets) {
      mockIo.sockets.sockets.clear();
      mockIo.sockets.sockets.set(globalMockSocket.id, globalMockSocket);
    }

    mockIo.on.mockClear();
    mockIo.to.mockClear();
    gameController = new GameController(mockIo as any, 'test-room');
  });

  test('No auto-start when expecting another human', () => {
    const joinPayload: JoinGamePayload = {
      playerName: 'Host',
      numHumans: 2,
      numCPUs: 1,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(
      globalMockSocket,
      joinPayload
    );
    expect(gameController['gameState'].started).toBe(false);
    expect(gameController['players'].has('COMPUTER_1')).toBe(false);
  });
});

describe('Game Flow - Manual Start by Host', () => {
  let gameController: GameController;

  beforeEach(() => {
    topLevelEmitMock = jest.fn();
    mockIo = createMockIO(topLevelEmitMock);

    globalMockSocket = createMockSocket('host-socket-id', topLevelEmitMock);

    if (mockIo.sockets && mockIo.sockets.sockets) {
      mockIo.sockets.sockets.clear();
      mockIo.sockets.sockets.set(globalMockSocket.id, globalMockSocket);
    }

    mockIo.on.mockClear();
    mockIo.to.mockClear();
    topLevelEmitMock.mockClear();
    // Pass a dummy roomId for tests (required by GameController constructor)
    gameController = new GameController(mockIo as any, 'test-room');
  });

  test('Host joins (no auto-CPUs), Player2 joins, Host starts game (no explicit CPUs)', async () => {
    topLevelEmitMock.mockClear();

    const originalHostSocketId = globalMockSocket.id;
    if (mockIo.sockets.sockets.has(originalHostSocketId)) {
      mockIo.sockets.sockets.delete(originalHostSocketId);
    }

    globalMockSocket.id = 'socket-A';
    globalMockSocket.emit = jest.fn((event: string, payload?: any) => {
      topLevelEmitMock(event, payload);
    });
    // Ensure the GameController can find this socket by its new ID
    if (mockIo.sockets && mockIo.sockets.sockets) {
      // Ensure sockets map exists
      mockIo.sockets.sockets.set(globalMockSocket.id, globalMockSocket);
    }

    const playerAJoin: JoinGamePayload = {
      playerName: 'PlayerA',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(
      globalMockSocket,
      playerAJoin
    );

    // Check that a JOINED event with the correct payload was emitted (allowing for extra events)
    const joinedCallHost = globalMockSocket.emit.mock.calls.find(
      (call: any) =>
        call[0] === JOINED &&
        call[1]?.success === true &&
        call[1]?.roomId === 'test-room' &&
        call[1]?.playerId === globalMockSocket.id
    );
    expect(joinedCallHost).toBeDefined();
    // Player IDs are now generated, so check by name
    const playerA = Array.from(gameController['players'].values()).find(
      (p) => p.name === playerAJoin.playerName
    );
    expect(playerA).toBeDefined();
    let stateUpdateCallHost = topLevelEmitMock.mock.calls.find(
      (call: any) =>
        call[0] === STATE_UPDATE && (call[1] as StatePayload)?.started === false
    );
    expect(stateUpdateCallHost).toBeDefined();
    if (stateUpdateCallHost)
      expect((stateUpdateCallHost[1] as StatePayload).players.length).toBe(1);
    // Only clear mocks after all assertions
    topLevelEmitMock.mockClear();
    globalMockSocket.emit.mockClear();

    const playerBJoinSocket: MockSocket = {
      id: 'socket-B',
      join: jest.fn(),
      emit: jest.fn((event: string, payload?: any) => {
        topLevelEmitMock(event, payload);
      }),
      on: jest.fn(
        (event: string, handler: (data?: any, ack?: Function) => void) => {
          (playerBJoinSocket.eventHandlers as any)[event as string] = handler;
        }
      ),
      removeAllListeners: jest.fn(),
      eventHandlers: {},
      simulateIncomingEvent: (event, data, ack) => {
        if ((playerBJoinSocket.eventHandlers as any)[event as string]) {
          (playerBJoinSocket.eventHandlers as any)[event as string](data, ack);
        }
      },
      disconnect: jest.fn(),
      off: jest.fn(),
    };
    mockIo.sockets.sockets.set(playerBJoinSocket.id, playerBJoinSocket);

    const playerBJoin: JoinGamePayload = {
      playerName: 'PlayerB',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(
      playerBJoinSocket,
      playerBJoin
    );
    // Check that a JOINED event with the correct payload was emitted for player B
    const joinedCallB = playerBJoinSocket.emit.mock.calls.find(
      (call: any) =>
        call[0] === JOINED &&
        call[1]?.success === true &&
        call[1]?.roomId === 'test-room' &&
        call[1]?.playerId === playerBJoinSocket.id
    );
    expect(joinedCallB).toBeDefined();
    // Check both players are present by name
    const playerB = Array.from(gameController['players'].values()).find(
      (p) => p.name === playerBJoin.playerName
    );
    expect(playerB).toBeDefined();
    expect(
      Array.from(gameController['players'].values()).map((p) => p.name)
    ).toEqual(
      expect.arrayContaining([playerAJoin.playerName, playerBJoin.playerName])
    );
    expect(topLevelEmitMock).toHaveBeenCalledWith(
      LOBBY_STATE_UPDATE,
      expect.objectContaining({
        players: expect.arrayContaining([
          expect.objectContaining({ name: playerAJoin.playerName }),
          expect.objectContaining({ name: playerBJoin.playerName }),
        ]),
      })
    );
    let stateUpdateCallPlayer2 = topLevelEmitMock.mock.calls.find(
      (call) =>
        call[0] === STATE_UPDATE &&
        (call[1] as StatePayload)?.started === false &&
        (call[1] as StatePayload)?.players.length === 2
    );
    expect(stateUpdateCallPlayer2).toBeDefined();
    if (stateUpdateCallPlayer2)
      expect((stateUpdateCallPlayer2[1] as StatePayload).players.length).toBe(
        2
      );
    topLevelEmitMock.mockClear();
    globalMockSocket.emit.mockClear();

    // Check if gameState.started is false before trying to start the game
    expect(gameController['gameState'].started).toBe(false);

    globalMockSocket.id = 'socket-A';
    // Call the controller's startGame logic directly instead of simulating the event
    (gameController['handleStartGame'] as Function)({
      computerCount: 0,
      socket: globalMockSocket,
    });

    // After starting, the gameState.deck should be initialized with cards
    expect(gameController['gameState'].deck).not.toBeNull();
    expect(gameController['gameState'].deck!.length).toBe(52 - 2 * 9 - 1);
    const playerA_Instance = Array.from(
      gameController['players'].values()
    ).find((p) => p.name === playerAJoin.playerName);
    const playerB_Instance = Array.from(
      gameController['players'].values()
    ).find((p) => p.name === playerBJoin.playerName);
    expect(playerA_Instance && playerA_Instance.hand.length).toBe(3);
    expect(playerB_Instance && playerB_Instance.hand.length).toBe(3);

    const stateUpdateCallStart = topLevelEmitMock.mock.calls.find(
      (call) =>
        call[0] === STATE_UPDATE && (call[1] as StatePayload)?.started === true
    );
    expect(stateUpdateCallStart).toBeDefined();
    if (stateUpdateCallStart) {
      expect((stateUpdateCallStart[1] as StatePayload).players.length).toBe(2);
      // The first player is the human who joined first
      expect(
        (stateUpdateCallStart[1] as StatePayload).players.some(
          (p: any) => p.name === playerAJoin.playerName
        )
      ).toBe(true);
    }

    const nextTurnCall = topLevelEmitMock.mock.calls.find(
      (call) => call[0] === NEXT_TURN
    );
    expect(nextTurnCall).toBeDefined();
    // The first player to act is the first human
    if (nextTurnCall && playerA_Instance)
      expect(nextTurnCall[1]).toMatchObject({ currentPlayerId: playerA_Instance.id });
  });
});

// Custom GameState for maxPlayers test
class TestGameState extends GameState {
  constructor() {
    super();
    Object.defineProperty(this, 'maxPlayers', { value: 2 });
  }
}

describe('Comprehensive Join/Lobby/Start Flow Edge Cases', () => {
  let gameController: GameController;
  let socketA: MockSocket;
  let socketB: MockSocket;
  let socketC: MockSocket;

  beforeEach(() => {
    topLevelEmitMock.mockClear();
    socketA = createMockSocket('socket-A', topLevelEmitMock);
    socketB = createMockSocket('socket-B', topLevelEmitMock);
    socketC = createMockSocket('socket-C', topLevelEmitMock);
    mockIo = createMockIO(topLevelEmitMock);
    mockIo.sockets.sockets.clear();
    mockIo.sockets.sockets.set(socketA.id, socketA);
    mockIo.sockets.sockets.set(socketB.id, socketB);
    mockIo.sockets.sockets.set(socketC.id, socketC);
    // Ensure all sockets in the map have their emit patched
    for (const sock of mockIo.sockets.sockets.values()) {
      sock.emit = jest.fn((event: string, payload?: any) =>
        topLevelEmitMock(event, payload)
      );
    }
    // Debug: log all socket ids and their emit function type
    // console.log('SOCKETS IN MAP:', Array.from(mockIo.sockets.sockets.entries()).map(([id, s]) => ({ id, emitType: typeof s.emit })));
    gameController = new GameController(mockIo as any, 'test-room');
  });

  test('Rejects new joins while the game is starting', () => {
    const hostJoin: JoinGamePayload = {
      playerName: 'Host',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, hostJoin);

    gameController['gameState'].isStarting = true;

    const joiner: JoinGamePayload = {
      playerName: 'Joiner',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };

    const ack = jest.fn();
    (gameController['publicHandleJoin'] as Function)(socketB, joiner, ack);

    expect(ack).toHaveBeenCalledWith(
      expect.objectContaining({
        success: false,
      })
    );
    expect(String(ack.mock.calls[0]?.[0]?.error || '')).toMatch(/starting/i);
  });

  test('Prevents duplicate join with same socket/player ID', () => {
    const joinPayload: JoinGamePayload = {
      id: socketA.id,
      playerName: 'Alpha',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    let errorResult;
    (gameController['publicHandleJoin'] as Function)(
      socketA,
      joinPayload,
      (result: any) => {
        errorResult = result;
      }
    );
    // Try to join again with same socket
    (gameController['publicHandleJoin'] as Function)(
      socketA,
      joinPayload,
      (result: any) => {
        errorResult = result;
      }
    );
    // Should return error for duplicate
    expect(errorResult && (errorResult as any).error).toBeDefined();
    // Only one player in the list
    expect(Array.from(gameController['players'].values()).length).toBe(1);
  });

  test('Allows session takeover on refresh (same playerId, new socket)', () => {
    const joinPayload: JoinGamePayload = {
      id: 'PLAYER_1',
      playerName: 'Alpha',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };

    (gameController['publicHandleJoin'] as Function)(socketA, joinPayload);
    const player = (gameController as any).players.get('PLAYER_1');
    expect(player).toBeDefined();
    expect(player.socketId).toBe(socketA.id);

    // Simulate a browser refresh: same logical player, new socket id.
    (gameController['publicHandleJoin'] as Function)(socketB, joinPayload);

    const updated = (gameController as any).players.get('PLAYER_1');
    expect(updated.socketId).toBe(socketB.id);

    // Old socket mapping is cleaned up so we don't have ghost lookups.
    expect((gameController as any).socketIdToPlayerId.get(socketA.id)).toBe(
      undefined
    );
    expect((gameController as any).socketIdToPlayerId.get(socketB.id)).toBe(
      'PLAYER_1'
    );

    // Old socket is forcefully disconnected for single-session semantics.
    expect(socketA.disconnect).toHaveBeenCalled();

    // Still only one player record.
    expect(Array.from((gameController as any).players.values()).length).toBe(1);
  });

  test('Join with missing/invalid playerName is rejected', () => {
    const joinPayload: any = { numHumans: 1, numCPUs: 0, roomId: 'test-room' };
    let errorResult: any;
    (gameController['publicHandleJoin'] as Function)(
      socketA,
      joinPayload,
      (result: any) => {
        errorResult = result;
      }
    );
    expect(errorResult && (errorResult as any).error).toBeDefined();
    expect(Array.from(gameController['players'].values()).length).toBe(0);
  });

  test('Join with whitespace/empty playerName is rejected', () => {
    const joinPayload: any = {
      playerName: '   ',
      numHumans: 1,
      numCPUs: 0,
      roomId: 'test-room',
    };
    let errorResult: any;
    (gameController['publicHandleJoin'] as Function)(
      socketA,
      joinPayload,
      (result: any) => {
        errorResult = result;
      }
    );
    expect(errorResult && errorResult.error).toBeDefined();
    expect(Array.from(gameController['players'].values()).length).toBe(0);
  });

  test('Rejoin logic restores player state', () => {
    // Use correct payload structure and ensure join works
    const joinPayload: JoinGamePayload = {
      playerName: 'Bravo',
      numHumans: 2, // must be >= 1 and total >= 2
      numCPUs: 1,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayload);
    const playerId = Array.from(gameController['players'].keys())[0];
    expect(gameController['players'].has(playerId)).toBe(true);
    // Simulate disconnect
    gameController['players'].get(playerId)!.disconnected = true;
    // Rejoin
    (gameController['publicHandleRejoin'] as Function)(
      socketA,
      'test-room',
      playerId
    );
    expect(gameController['players'].get(playerId)!.disconnected).toBe(false);
    expect(topLevelEmitMock).toHaveBeenCalledWith(
      JOINED,
      expect.objectContaining({ success: true, roomId: 'test-room', playerId })
    );
  });

  test('Host reassignment when host disconnects before game start', () => {
    const joinPayloadA: JoinGamePayload = {
      playerName: 'Host',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    const joinPayloadB: JoinGamePayload = {
      playerName: 'Guest',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayloadA);
    (gameController['publicHandleJoin'] as Function)(socketB, joinPayloadB);
    // Simulate host disconnect
    const hostId = Array.from(gameController['players'].keys())[0];
    gameController['players'].get(hostId)!.disconnected = true;
    // Reassign host
    gameController['hostId'] = Array.from(gameController['players'].keys())[1];
    expect(
      gameController['players'].get(gameController['hostId'])!.status
    ).toBe('joined');
    // Optionally, update status to 'host' in your logic
  });

  test('Prevents join when room is full', () => {
    // Use custom GameState with maxPlayers = 2
    gameController['gameState'] = new TestGameState() as any;
    const joinPayloadA: JoinGamePayload = {
      id: socketA.id,
      playerName: 'A',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    const joinPayloadB: JoinGamePayload = {
      id: socketB.id,
      playerName: 'B',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    const joinPayloadC: JoinGamePayload = {
      id: socketC.id,
      playerName: 'C',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(
      socketA,
      joinPayloadA,
      () => {}
    );
    (gameController['publicHandleJoin'] as Function)(
      socketB,
      joinPayloadB,
      () => {}
    );
    let errorResult: any;
    (gameController['publicHandleJoin'] as Function)(
      socketC,
      joinPayloadC,
      (result: any) => {
        errorResult = result;
      }
    );
    // Should return error for third join
    expect(errorResult && (errorResult as any).error).toBeDefined();
    expect(Array.from(gameController['players'].values()).length).toBe(2);
  });

  test('Prevents join after game has started', async () => {
    const joinPayloadA: JoinGamePayload = {
      id: socketA.id,
      playerName: 'A',
      numHumans: 2, // must be >= 1 and total >= 2
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayloadA);
    await (gameController['handleStartGame'] as Function)({
      computerCount: 1,
      socket: socketA,
    });
    const joinPayloadB: JoinGamePayload = {
      id: socketB.id,
      playerName: 'B',
      numHumans: 2, // must be >= 1 and total >= 2
      numCPUs: 0,
      roomId: 'test-room',
    };
    let errorResult: any = undefined;
    (gameController['publicHandleJoin'] as Function)(
      socketB,
      joinPayloadB,
      (result: any) => {
        errorResult = result;
      }
    );
    expect(errorResult && errorResult.error).toBeDefined();
    // Host and one CPU should be present
    expect(Array.from(gameController['players'].values()).length).toBe(2);
  });

  test('All relevant events are emitted with correct payloads', (done) => {
    const joinPayload: JoinGamePayload = {
      playerName: 'Eventful',
      numHumans: 2, // must be >= 1 and total >= 2
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(
      socketA,
      joinPayload,
      (_result: any) => {
        (gameController['handleStartGame'] as Function)({
          computerCount: 1,
          socket: socketA,
        })
          .then(() => {
            // Check for JOINED and STATE_UPDATE always
            const joinedEmitted = socketA.emit.mock.calls.some(
              (call: any) => call[0] === JOINED
            );
            const stateUpdateEmitted = topLevelEmitMock.mock.calls.some(
              (call) => call[0] === STATE_UPDATE
            );
            expect(joinedEmitted).toBe(true);
            expect(stateUpdateEmitted).toBe(true);
            // LOBBY is only emitted if there are enough players
            const lobbyEmitted = topLevelEmitMock.mock.calls.some(
              (call) => call[0] === LOBBY_STATE_UPDATE
            );
            expect(lobbyEmitted).toBe(true);
            done();
            return null;
          })
          .catch(done);
      }
    );
  });

  test('Does not emit JOINED or STATE_UPDATE on failed join', () => {
    const joinPayload: any = { numHumans: 0, numCPUs: 0, roomId: 'test-room' }; // Invalid payload
    (gameController['publicHandleJoin'] as Function)(
      socketA,
      joinPayload,
      (_result: any) => {}
    );
    // Should not emit JOINED or STATE_UPDATE
    const joinedEmitted = socketA.emit.mock.calls.some(
      (call: any) => call[0] === JOINED
    );
    const stateUpdateEmitted = topLevelEmitMock.mock.calls.some(
      (call) => call[0] === STATE_UPDATE
    );
    expect(joinedEmitted).toBe(false);
    expect(stateUpdateEmitted).toBe(false);
  });

  test('JOINED event payload is correct on successful join', () => {
    const joinPayload: JoinGamePayload = {
      playerName: 'PayloadTest',
      numHumans: 2,
      numCPUs: 1,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayload);
    const joinedCall = socketA.emit.mock.calls.find(
      (call: any) => call[0] === JOINED
    );
    expect(joinedCall).toBeDefined();
    const payload = joinedCall[1];
    expect(payload).toMatchObject({
      success: true,
      roomId: 'test-room',
      playerId: expect.any(String),
    });
  });

  test('Player can disconnect and reconnect during a game', async () => {
    const joinPayload: JoinGamePayload = {
      playerName: 'Reconnecter',
      numHumans: 2,
      numCPUs: 1,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayload);
    await (gameController['handleStartGame'] as Function)({
      computerCount: 1,
      socket: socketA,
    });
    const playerId = Array.from(gameController['players'].keys())[0];
    // Simulate disconnect
    gameController['players'].get(playerId)!.disconnected = true;
    // Simulate reconnect
    (gameController['publicHandleRejoin'] as Function)(
      socketA,
      'test-room',
      playerId
    );
    expect(gameController['players'].get(playerId)!.disconnected).toBe(false);
    // Should emit JOINED again
    const joinedCalls = socketA.emit.mock.calls.filter(
      (call: any) => call[0] === JOINED
    );
    expect(joinedCalls.length).toBeGreaterThan(1);
  });
});

describe('Game Flow - Automatic Start When All Humans Ready', () => {
  let gameController: GameController;
  let socketA: MockSocket;
  let socketB: MockSocket;

  beforeEach(() => {
    topLevelEmitMock.mockClear();
    socketA = createMockSocket('socket-A', topLevelEmitMock);
    socketB = createMockSocket('socket-B', topLevelEmitMock);
    mockIo = createMockIO(topLevelEmitMock);
    mockIo.sockets.sockets.clear();
    mockIo.sockets.sockets.set(socketA.id, socketA);
    mockIo.sockets.sockets.set(socketB.id, socketB);
    gameController = new GameController(mockIo as any, 'test-room');
  });

  test('Game auto-starts when all humans are ready', () => {
    // Arrange
    const joinPayloadA: JoinGamePayload = {
      playerName: 'Alice',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    const joinPayloadB: JoinGamePayload = {
      playerName: 'Bob',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayloadA);
    (gameController['publicHandleJoin'] as Function)(socketB, joinPayloadB);
    // Attach event handlers so simulateIncomingEvent works
    gameController.attachSocketEventHandlers(socketA as any);
    gameController.attachSocketEventHandlers(socketB as any);
    // Act
    socketA.simulateIncomingEvent(PLAYER_READY, { isReady: true });
    socketB.simulateIncomingEvent(PLAYER_READY, { isReady: true });
    // Assert
    expect(gameController['gameState'].started).toBe(true);
    const stateUpdateCall = topLevelEmitMock.mock.calls.find(
      (call) =>
        call[0] === STATE_UPDATE && (call[1] as StatePayload)?.started === true
    );
    expect(stateUpdateCall).toBeDefined();
    if (stateUpdateCall) {
      expect((stateUpdateCall[1] as StatePayload).players.length).toBe(2);
      expect(
        (stateUpdateCall[1] as StatePayload).players.some(
          (p: any) => p.name === 'Alice'
        )
      ).toBe(true);
      expect(
        (stateUpdateCall[1] as StatePayload).players.some(
          (p: any) => p.name === 'Bob'
        )
      ).toBe(true);
    }
  });
});

describe('Game Flow - Invalid Card Play', () => {
  let gameController: GameController;
  let socketA: MockSocket;
  let socketB: MockSocket;

  beforeEach(() => {
    jest.useFakeTimers();
    topLevelEmitMock.mockClear();
    mockIo = createMockIO(topLevelEmitMock);
    socketA = createMockSocket('socket-A', topLevelEmitMock);
    socketB = createMockSocket('socket-B', topLevelEmitMock);
    mockIo.sockets.sockets.clear();
    mockIo.sockets.sockets.set(socketA.id, socketA);
    mockIo.sockets.sockets.set(socketB.id, socketB);
    gameController = new GameController(mockIo as any, 'test-room');
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  test('Blocks player actions while the game is starting (until ANIMATIONS_COMPLETE)', () => {
    const joinPayloadA: JoinGamePayload = {
      playerName: 'Alice',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    const joinPayloadB: JoinGamePayload = {
      playerName: 'Bob',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayloadA);
    (gameController['publicHandleJoin'] as Function)(socketB, joinPayloadB);
    gameController.attachSocketEventHandlers(socketA as any);
    gameController.attachSocketEventHandlers(socketB as any);
    socketA.simulateIncomingEvent(PLAYER_READY, { isReady: true });
    socketB.simulateIncomingEvent(PLAYER_READY, { isReady: true });

    const playerA = Array.from(gameController['players'].values()).find(
      (p) => p.name === 'Alice'
    )!;
    gameController['gameState'].currentPlayerIndex = gameController[
      'gameState'
    ].players.indexOf(playerA.id);

    topLevelEmitMock.mockClear();
    socketA.simulateIncomingEvent(PLAY_CARD, { cardIndices: [0] });

    const errorCall = topLevelEmitMock.mock.calls.find(
      (call) => call[0] === ERROR && String(call[1]).includes('starting')
    );
    expect(errorCall).toBeDefined();
  });

  test('Player receives error when playing card with invalid index', () => {
    const joinPayloadA: JoinGamePayload = {
      playerName: 'Alice',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    const joinPayloadB: JoinGamePayload = {
      playerName: 'Bob',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayloadA);
    (gameController['publicHandleJoin'] as Function)(socketB, joinPayloadB);
    gameController.attachSocketEventHandlers(socketA as any);
    gameController.attachSocketEventHandlers(socketB as any);
    socketA.simulateIncomingEvent(PLAYER_READY, { isReady: true });
    socketB.simulateIncomingEvent(PLAYER_READY, { isReady: true });
    socketA.simulateIncomingEvent(ANIMATIONS_COMPLETE);

    const playerA = Array.from(gameController['players'].values()).find(
      (p) => p.name === 'Alice'
    )!;
    gameController['gameState'].currentPlayerIndex = gameController[
      'gameState'
    ].players.indexOf(playerA.id);

    const invalidPlayData = { cardIndices: [99] };
    socketA.simulateIncomingEvent(PLAY_CARD, invalidPlayData);

    const errorCall = topLevelEmitMock.mock.calls.find(
      (call) =>
        call[0] === ERROR &&
        typeof call[1] === 'string' &&
        call[1].includes('Invalid card index')
    );
    expect(errorCall).toBeDefined();
  });

  test('Invalid down card play forces pickup and advances turn', async () => {
    const joinPayloadA: JoinGamePayload = {
      playerName: 'Alice',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    const joinPayloadB: JoinGamePayload = {
      playerName: 'Bob',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayloadA);
    (gameController['publicHandleJoin'] as Function)(socketB, joinPayloadB);
    gameController.attachSocketEventHandlers(socketA as any);
    gameController.attachSocketEventHandlers(socketB as any);
    socketA.simulateIncomingEvent(PLAYER_READY, { isReady: true });
    socketB.simulateIncomingEvent(PLAYER_READY, { isReady: true });
    socketA.simulateIncomingEvent(ANIMATIONS_COMPLETE);

    const playerA = Array.from(gameController['players'].values()).find(
      (p) => p.name === 'Alice'
    )!;
    const playerB = Array.from(gameController['players'].values()).find(
      (p) => p.name === 'Bob'
    )!;

    gameController['gameState'].currentPlayerIndex = gameController[
      'gameState'
    ].players.indexOf(playerA.id);
    playerA.hand = [];
    playerA.upCards = [];
    playerA.downCards = [{ value: 4, suit: 'hearts' }];
    gameController['gameState'].pile = [{ value: 'K', suit: 'spades' }];
    gameController['gameState'].discard = [{ value: '9', suit: 'hearts' }];

    const expectedHandSize = gameController['gameState'].pile.length + 1;
    topLevelEmitMock.mockClear();

    const downPlay = { cardIndices: [0] };
    socketA.simulateIncomingEvent(PLAY_CARD, downPlay);

    jest.runOnlyPendingTimers();
    await Promise.resolve();

    expect(playerA.downCards.length).toBe(0);
    expect(playerA.hand.length).toBe(expectedHandSize);
    expect(gameController['gameState'].pile.length).toBe(0);
    expect(gameController['gameState'].discard.length).toBe(1);
    const pickupCall = topLevelEmitMock.mock.calls.find(
      (call) => call[0] === PILE_PICKED_UP
    );
    expect(pickupCall).toBeDefined();
    const currentPlayerId =
      gameController['gameState'].players[
        gameController['gameState'].currentPlayerIndex
      ];
    expect(currentPlayerId).toBe(playerB.id);
  });

  test('Pick up is rejected when a valid play exists', () => {
    const joinPayloadA: JoinGamePayload = {
      playerName: 'Alice',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    const joinPayloadB: JoinGamePayload = {
      playerName: 'Bob',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayloadA);
    (gameController['publicHandleJoin'] as Function)(socketB, joinPayloadB);
    gameController.attachSocketEventHandlers(socketA as any);
    gameController.attachSocketEventHandlers(socketB as any);
    socketA.simulateIncomingEvent(PLAYER_READY, { isReady: true });
    socketB.simulateIncomingEvent(PLAYER_READY, { isReady: true });
    socketA.simulateIncomingEvent(ANIMATIONS_COMPLETE);

    const playerA = Array.from(gameController['players'].values()).find(
      (p) => p.name === 'Alice'
    )!;
    gameController['gameState'].currentPlayerIndex = gameController[
      'gameState'
    ].players.indexOf(playerA.id);
    playerA.hand = [{ value: 'A', suit: 'spades' }];
    gameController['gameState'].pile = [{ value: '3', suit: 'clubs' }];

    topLevelEmitMock.mockClear();
    socketA.simulateIncomingEvent(PICK_UP_PILE);

    const errorCall = topLevelEmitMock.mock.calls.find(
      (call) => call[0] === ERROR && String(call[1]).includes('playable')
    );
    expect(errorCall).toBeDefined();
    expect(gameController['gameState'].pile.length).toBe(1);
  });
});

describe('Game Flow - Special Card Effects', () => {
  let gameController: GameController;
  let hostSocket: MockSocket;

  beforeEach(() => {
    jest.useFakeTimers();
    topLevelEmitMock.mockClear();
    mockIo = createMockIO(topLevelEmitMock);
    hostSocket = createMockSocket('host-socket', topLevelEmitMock);
    mockIo.sockets.sockets.clear();
    mockIo.sockets.sockets.set(hostSocket.id, hostSocket);
    gameController = new GameController(mockIo as any, 'test-room');
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  test('CPU burn advances to the next player', async () => {
    const joinPayload: JoinGamePayload = {
      playerName: 'Host',
      numHumans: 1,
      numCPUs: 1,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(hostSocket, joinPayload);
    (gameController['handleStartGame'] as Function)({
      computerCount: 1,
      socket: hostSocket,
    });

    const cpuPlayer = Array.from(gameController['players'].values()).find(
      (p) => p.isComputer
    )!;
    const cpuIndex = gameController['gameState'].players.indexOf(cpuPlayer.id);
    gameController['gameState'].currentPlayerIndex = cpuIndex;

    cpuPlayer.hand = [{ value: 10, suit: 'hearts' }];
    gameController['gameState'].pile = [{ value: 9, suit: 'clubs' }];

    const scheduleSpy = jest
      .spyOn(gameController as any, 'scheduleComputerTurn')
      .mockImplementation(() => undefined);

    topLevelEmitMock.mockClear();

    (gameController as any)['handlePlayCardInternal'](cpuPlayer, [0], 'hand', [
      cpuPlayer.hand[0],
    ]);

    jest.runOnlyPendingTimers();
    await Promise.resolve();

    const nextTurnCall = topLevelEmitMock.mock.calls.find(
      (call) =>
        call[0] === NEXT_TURN && (call[1] as any)?.currentPlayerId === hostSocket.id
    );
    expect(nextTurnCall).toBeDefined();
    expect(scheduleSpy).not.toHaveBeenCalled();
    expect(gameController['gameState'].pile.length).toBe(0);
    expect(gameController['gameState'].discard.length).toBe(0);

    scheduleSpy.mockRestore();
  });
});

describe('Game Flow - 3 Player Full Game Simulation', () => {
  let gameController: GameController;
  let sockets: MockSocket[];
  let playerData: JoinGamePayload[];

  beforeEach(() => {
    topLevelEmitMock.mockClear();
    sockets = [];
    playerData = [
      {
        playerName: 'Host',
        id: 'HOST_ID',
        numHumans: 3,
        numCPUs: 1,
        roomId: 'test-room',
      },
      {
        playerName: 'Alice',
        id: 'ALICE_ID',
        numHumans: 3,
        numCPUs: 1,
        roomId: 'test-room',
      },
    ];
    for (let i = 0; i < 2; i++) {
      const s: MockSocket = {
        id: `socket-${i}`,
        join: jest.fn(),
        emit: jest.fn((event: string, payload?: any) => {
          topLevelEmitMock(event, payload);
        }),
        on: jest.fn(
          (event: string, handler: (data?: any, ack?: Function) => void) => {
            s.eventHandlers[event as string] = handler;
          }
        ),
        removeAllListeners: jest.fn(),
        eventHandlers: {},
        simulateIncomingEvent: (event, data, ack) => {
          if (s.eventHandlers[event as string]) {
            s.eventHandlers[event as string](data, ack);
          }
        },
        disconnect: jest.fn(),
        off: jest.fn(),
      };
      sockets.push(s);
    }
    if (mockIo.sockets && mockIo.sockets.sockets) {
      mockIo.sockets.sockets.clear();
      sockets.forEach((s) => mockIo.sockets.sockets.set(s.id, s));
    }
    mockIo.on.mockClear();
    mockIo.to.mockClear();
    gameController = new GameController(mockIo as any, 'test-room');
  });

  test('Full 3-player game flow, win, GAME_OVER, and restart', () => {
    (gameController['publicHandleJoin'] as Function)(sockets[0], playerData[0]);
    (gameController['publicHandleJoin'] as Function)(sockets[1], playerData[1]);
    (gameController['handleStartGame'] as Function)({
      computerCount: 1,
      socket: sockets[0],
    });

    expect(gameController['players'].has('COMPUTER_1')).toBe(true);
    expect(gameController['players'].get('COMPUTER_1')?.isComputer).toBe(true);
    expect(gameController['gameState'].players.length).toBe(3);

    expect(gameController['gameState'].started).toBe(true);
    for (const id of gameController['gameState'].players) {
      const p = gameController['players'].get(id);
      expect(p).toBeDefined();
      expect(p!.hand.length).toBe(3);
    }

    for (let turn = 0; turn < 3; turn++) {
      const currentPlayerId =
        gameController['gameState'].players[
          gameController['gameState'].currentPlayerIndex
        ];
      const player = gameController['players'].get(currentPlayerId)!;
      const cardIndices = [0];
      const zone = 'hand';
      (gameController as any)['handlePlayCardInternal'](
        player,
        cardIndices,
        zone,
        [player.hand[0]]
      );
    }

    const winnerId = gameController['gameState'].players[0];
    const winner = gameController['players'].get(winnerId)!;
    winner.hand = [];
    winner.upCards = [];
    winner.downCards = [];
    gameController['gameState'].started = false;
    topLevelEmitMock.mockClear();
    gameController['io'].to(gameController['roomId']).emit(GAME_OVER, winnerId);
    const gameOverCall = topLevelEmitMock.mock.calls.find(
      (call) => call[0] === GAME_OVER
    );
    expect(gameOverCall).toBeDefined();
    expect(gameOverCall![1]).toEqual(winnerId);

    gameController['gameState'].endGameInstance();
    (gameController['handleStartGame'] as Function)({
      computerCount: 1,
      socket: sockets[0],
    });
    expect(gameController['gameState'].started).toBe(true);
    for (const id of gameController['gameState'].players) {
      const p = gameController['players'].get(id);
      expect(p).toBeDefined();
      expect(p!.hand.length).toBe(3);
    }
  });
});

describe('State Validation Guards', () => {
  let gameController: GameController;
  let socketA: MockSocket;

  beforeEach(() => {
    topLevelEmitMock = jest.fn();
    mockIo = createMockIO(topLevelEmitMock);
    socketA = createMockSocket('socket-A', topLevelEmitMock);
    mockIo.sockets.sockets.clear();
    mockIo.sockets.sockets.set(socketA.id, socketA);
    gameController = new GameController(mockIo as any, 'test-room');
  });

  test('Start game aborts with invalid state', async () => {
    const joinPayload: JoinGamePayload = {
      playerName: 'Host',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayload);
    const playerId = Array.from(gameController['players'].keys())[0];
    gameController['gameState'].players.push(playerId);

    await (gameController['handleStartGame'] as Function)({
      computerCount: 1,
      socket: socketA,
    });

    const errorCall = topLevelEmitMock.mock.calls.find(
      (call) =>
        call[0] === ERROR && String(call[1]).includes('Invalid game state')
    );
    expect(errorCall).toBeDefined();
  });

  test('Rejoin aborts when state is inconsistent', () => {
    const joinPayload: JoinGamePayload = {
      playerName: 'Host',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayload);
    topLevelEmitMock.mockClear();
    const playerId = Array.from(gameController['players'].keys())[0];
    gameController['players'].get(playerId)!.disconnected = true;
    gameController['gameState'].players.push(playerId);

    let ackResult: any;
    (gameController['publicHandleRejoin'] as Function)(
      socketA,
      'test-room',
      playerId,
      (result: any) => {
        ackResult = result;
      }
    );

    expect(ackResult && ackResult.error).toBeDefined();
    const joinedEmitted = topLevelEmitMock.mock.calls.some(
      (call) => call[0] === JOINED
    );
    expect(joinedEmitted).toBe(false);
  });
});
