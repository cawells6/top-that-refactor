This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.eslintrc.js
.gitignore
babel.config.cjs
controllers/GameController.js
jest-globals.d.ts
jest.config.cjs
models/GameState.js
models/Player.js
package.json
public/index.html
public/scripts/events.js
public/scripts/render.js
public/scripts/state.js
public/shared/events.js
public/src/shared/events.js
public/style.css
server.js
src/shared/events.js
tests/cardUtils.test.js
tests/gameFlow.test.js
tests/gameState.deck.test.js
tests/gameState.test.js
tests/player.test.js
tsconfig.json
utils/cardUtils.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".eslintrc.js">
module.exports = {
  root: true,
  env: {
    browser: true,
    node: true,
    es2021: true,
  },
  extends: [
    'eslint:recommended',
  ],  rules: {
    'no-import-assign': 'error',
    'import/no-named-as-default-member': 'warn',
    // ...add other rules as needed
  },
};
</file>

<file path="babel.config.cjs">
// babel.config.cjs
module.exports = {
  presets: [
    ['@babel/preset-env', { targets: { node: 'current' } }]
  ]
};
</file>

<file path="jest-globals.d.ts">
// jest-globals.d.ts
// This file tells TypeScript about Jest's global functions and other globals

declare global {
  // Socket.IO client
  function io(url?: string | object, options?: object): any;
}

export {}; // This ensures this file is treated as a module
</file>

<file path="public/shared/events.js">
// public/shared/events.js
// Shared Socket.IO event constants (served to browser)

/** Client requests to join a game (short form, legacy) */
export const JOIN = 'join';

/** Client requests to join a game (preferred long form) */
export const JOIN_GAME = 'join-game';

/** Server confirms a client has joined and provides their ID/room */
export const JOINED = 'joined';

/** Server notifies all clients that a player has joined */
export const PLAYER_JOINED = 'player-joined';

/** Server emits lobby state (room, players, maxPlayers) */
export const LOBBY = 'lobby';

/** Server emits the current game state (preferred long form) */
export const STATE_UPDATE = 'state-update';

/** Client requests to rejoin a game after disconnect */
export const REJOIN = 'rejoin';

/** Server notifies client of a special card played (e.g., two, five, ten) */
export const SPECIAL_CARD = 'special-card';

/** Server notifies clients of the next player's turn */
export const NEXT_TURN = 'next-turn';

/** Client requests to start the game */
export const START_GAME = 'start-game';
</file>

<file path="public/src/shared/events.js">
/**
 * @constant {string} JOIN
 * @description Client requests to join a game (short form, legacy).
 */
export const JOIN = 'join';

/**
 * @constant {string} JOIN_GAME
 * @description Client requests to join a game (preferred long form).
 */
export const JOIN_GAME = 'join-game';

/**
 * @constant {string} JOINED
 * @description Server confirms a client has joined and provides their ID/room.
 */
export const JOINED = 'joined';

/**
 * @constant {string} PLAYER_JOINED
 * @description Server notifies all clients that a player has joined.
 */
export const PLAYER_JOINED = 'player-joined';

/**
 * @constant {string} LOBBY
 * @description Server emits lobby state (room, players, maxPlayers).
 */
export const LOBBY = 'lobby';

/**
 * @constant {string} STATE
 * @description Server emits the current game state (short form, legacy).
 */
export const STATE = 'state';

/**
 * @constant {string} STATE_UPDATE
 * @description Server emits the current game state (preferred long form).
 */
export const STATE_UPDATE = 'state-update';

/**
 * @constant {string} SPECIAL_CARD
 * @description Server notifies client of a special card played (e.g., two, five, ten).
 */
export const SPECIAL_CARD = 'special-card';

/**
 * @constant {string} REJOIN
 * @description Client requests to rejoin a game after disconnect.
 */
export const REJOIN = 'rejoin';

/**
 * @constant {string} START_GAME
 * @description Client requests to start the game.
 */
export const START_GAME = 'start-game';

/**
 * @constant {string} NEXT_TURN
 * @description Server notifies clients of the next player's turn.
 */
export const NEXT_TURN = 'next-turn';
</file>

<file path="src/shared/events.js">
/**
 * @constant {string} JOIN
 * @description Client requests to join a game (short form, legacy).
 */
export const JOIN = 'join';

/**
 * @constant {string} JOIN_GAME
 * @description Client requests to join a game (preferred long form).
 */
export const JOIN_GAME = 'join-game';

/**
 * @constant {string} JOINED
 * @description Server confirms a client has joined and provides their ID/room.
 */
export const JOINED = 'joined';

/**
 * @constant {string} PLAYER_JOINED
 * @description Server notifies all clients that a player has joined.
 */
export const PLAYER_JOINED = 'player-joined';

/**
 * @constant {string} LOBBY
 * @description Server emits lobby state (room, players, maxPlayers).
 */
export const LOBBY = 'lobby';

/**
 * @constant {string} STATE
 * @description Server emits the current game state (short form, legacy).
 */
export const STATE = 'state';

/**
 * @constant {string} STATE_UPDATE
 * @description Server emits the current game state (preferred long form).
 */
export const STATE_UPDATE = 'state-update';

/**
 * @constant {string} SPECIAL_CARD
 * @description Server notifies client of a special card played (e.g., two, five, ten).
 */
export const SPECIAL_CARD = 'special-card';

/**
 * @constant {string} REJOIN
 * @description Client requests to rejoin a game after disconnect.
 */
export const REJOIN = 'rejoin';

/**
 * @constant {string} START_GAME
 * @description Client requests to start the game.
 */
export const START_GAME = 'start-game';

/**
 * @constant {string} NEXT_TURN
 * @description Server notifies clients of the next player's turn.
 */
export const NEXT_TURN = 'next-turn';
</file>

<file path="tests/gameFlow.test.js">
import GameController from '../controllers/GameController.js';
import { 
  JOIN_GAME, 
  JOINED, 
  PLAYER_JOINED,
  LOBBY,
  STATE_UPDATE,
  START_GAME
} from '../src/shared/events.js';

describe('Game flow tests', () => {
  let io, sockets, controller;
  
  // Socket.IO mock setup
  beforeEach(() => {
    sockets = {};
    io = {
      to: jest.fn().mockReturnThis(),
      emit: jest.fn(),
      on: jest.fn((event, callback) => {
        if (event === 'connection') {
          // Store the callback to simulate connections later
          io.connectionCallback = callback;
        }
      }),
      // Add missing required Socket.IO Server properties
      sockets: { emit: jest.fn() },
      engine: {},
      httpServer: {},
      path: () => '/',
      adapter: {},
      // Add any other required properties used by your GameController
    };
    
    // @ts-ignore - We're using a simplified mock of Socket.IO server
    controller = new GameController(io);
  });
  
  test('JOIN â†’ lobby â†’ START_GAME flow emits STATE_UPDATE without errors', () => {
    // Create mock sockets
    const socket1 = createMockSocket('socket1');
    const socket2 = createMockSocket('socket2');
    
    // Simulate connections
    io.connectionCallback(socket1);
    io.connectionCallback(socket2);
    
    // Test JOIN_GAME for player1
    socket1.emit(JOIN_GAME, 'player1');
    
    // Verify socket1 received JOINED event with correct data
    expect(socket1.emit).toHaveBeenCalledWith(JOINED, {
      id: 'player1',
      roomId: 'game-room'
    });
    
    // Verify socket1 joined the room
    expect(socket1.join).toHaveBeenCalledWith('game-room');
    
    // Verify PLAYER_JOINED was emitted to the room
    expect(io.to).toHaveBeenCalledWith('game-room');
    expect(io.emit).toHaveBeenCalledWith(PLAYER_JOINED, ['player1']);
    
    // Verify LOBBY data was emitted
    expect(io.to).toHaveBeenCalledWith('game-room');
    expect(io.emit).toHaveBeenCalledWith(LOBBY, {
      roomId: 'game-room',
      players: ['player1'],
      maxPlayers: 4
    });
    
    // Test JOIN_GAME for player2
    socket2.emit(JOIN_GAME, 'player2');
    
    // Verify socket2 received JOINED event
    expect(socket2.emit).toHaveBeenCalledWith(JOINED, {
      id: 'player2',
      roomId: 'game-room'
    });
    
    // Start the game
    socket1.emit(START_GAME);
    
    // Verify STATE_UPDATE was emitted with game state
    expect(io.to).toHaveBeenCalledWith('game-room');
    expect(io.emit).toHaveBeenCalledWith(STATE_UPDATE, expect.objectContaining({
      players: expect.any(Array),
      currentPlayer: expect.any(String)
    }));
  });
  
  // Helper function to create mock socket
  function createMockSocket(id) {
    const socket = {
      id,
      emit: jest.fn(),
      on: jest.fn(),
      join: jest.fn()
    };
    
    // Store handlers for events
    const handlers = {};
    
    // Override on method to store handlers
    socket.on = jest.fn((event, handler) => {
      handlers[event] = handler;
    });
    
    // Add emit method to trigger stored handlers
    socket.emit = jest.fn((event, ...args) => {
      if (event && handlers[event]) {
        handlers[event](...args);
      }
    });
    
    sockets[id] = socket;
    return socket;
  }
});
</file>

<file path="tests/gameState.deck.test.js">
import GameState from '../models/GameState.js';

describe('GameState deck and dealCards', () => {
  test('buildDeck creates 52 unique cards and shuffles', () => {
    const gs = new GameState();
    gs.buildDeck();
    expect(gs.deck).toHaveLength(52);
    // Check for uniqueness
    const cardSet = new Set(gs.deck.map(c => `${c.value}-${c.suit}`));
    expect(cardSet.size).toBe(52);
    // Check that deck is shuffled (not in order)
    const ordered = [];
    const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
    const values = [2,3,4,5,6,7,8,9,10,'J','Q','K','A'];
    for (const suit of suits) for (const value of values) ordered.push(`${value}-${suit}`);
    const deckStr = gs.deck.map(c => `${c.value}-${c.suit}`).join(',');
    expect(deckStr).not.toBe(ordered.join(','));
  });

  test('dealCards deals correct hand/up/down sizes and leaves leftovers', () => {
    const gs = new GameState();
    gs.buildDeck();
    const { hands, upCards, downCards } = gs.dealCards(3, 3);
    expect(hands).toHaveLength(3);
    expect(upCards).toHaveLength(3);
    expect(downCards).toHaveLength(3);
    hands.forEach(h => expect(h).toHaveLength(3));
    upCards.forEach(u => expect(u).toHaveLength(3));
    downCards.forEach(d => expect(d).toHaveLength(3));
    // 3 players * 3 * 3 = 27 cards dealt, 25 left
    expect(gs.deck.length).toBe(52 - 27);
  });
});
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es2022",
    "module": "es2022",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "allowJs": true,
    "checkJs": true,
    "noEmit": true,
    "strict": false,
    "types": ["jest"]
  },
  "include": ["**/*.js", "**/*.mjs", "**/*.cjs", "**/*.d.ts"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path=".gitignore">
node_modules/
</file>

<file path="jest.config.cjs">
// jest.config.cjs
module.exports = {
  testEnvironment: 'node',
  transform: {
    '^.+\\.js$': ['babel-jest', { configFile: './babel.config.cjs' }]
  },
  testMatch: ['**/tests/**/*.test.js'],
  // Handle ES modules
  moduleFileExtensions: ['js', 'mjs', 'cjs', 'json'],
  // Use Node resolution
  moduleDirectories: ['node_modules']
};
</file>

<file path="public/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TopÂ That! â€“ Card Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Your CSS -->
  <link rel="stylesheet" href="/style.css" />

  <!-- Socket.IO client -->
  <script defer src="/socket.io/socket.io.js"></script>

  <!-- Entryâ€‘point for your client modules -->
  <script defer type="module" src="/scripts/events.js"></script>
</head>
<body>
  <header id="main-header">
    <div class="header-content">
      <div class="brand">
        <h1 class="logo">
          <span class="logo-icon">ðŸ‘‘</span> TopÂ That!
        </h1>
        <p class="tagline">OneÂ Pile.Â OneÂ Winner.Â NoÂ Mercy.</p>
      </div>
      <nav>
        <button id="rules-button" class="btn btn-secondary" aria-haspopup="dialog">
          HowÂ toÂ Play
        </button>
        <button id="back-to-lobby-button" class="btn btn-secondary">
          Lobby
        </button>
        <button id="rewind-btn" class="btn btn-secondary hidden">â—€Â Prev</button>
        <button id="forward-btn" class="btn btn-secondary hidden">NextÂ â–¶</button>
      </nav>
    </div>
  </header>

  <div id="notice-banner" class="notice hidden"></div>
  <div id="error-banner" class="notice hidden"></div>
  <div id="modal-overlay" class="hidden"></div>

  <main id="main-content">
    <!-- Lobby Screen -->
    <div id="lobby-container" class="hidden">
      <div id="lobby-form-card">
        <h2 id="lobby-heading">Join a Game</h2>
        <div id="lobby-form-content">
          <div class="form-group">
            <label for="name">Your Name</label>
            <input type="text" id="name" placeholder="Enter your name" required />
            <div id="name-error" class="error-message hidden">
              Please enter your name.
            </div>
          </div>
          <div class="form-group">
            <label for="total-players">Total Players <small>(maxÂ 4)</small></label>
            <input type="number" id="total-players" min="2" max="4" value="2" />
          </div>
          <div class="form-group">
            <label for="computer-count">Computer Opponents</label>
            <input type="number" id="computer-count" min="0" max="3" value="0" />
          </div>
          <div class="form-group button-group">
            <button id="create-join" class="btn btn-primary">
              CreateÂ /Â Join Game
            </button>
          </div>
        </div>
        <div id="waiting-state" class="hidden">
          <h3 id="waiting-heading">Waiting for playersâ€¦</h3>
          <div class="spinner">
            <div class="dot1"></div><div class="dot2"></div>
          </div>
          <p id="share-link-message">
            Share the link to invite others!
          </p>
          <button id="copy-link-button" class="btn btn-tertiary">
            Copy Invite Link
          </button>
          <button id="start-game-button" class="btn btn-primary hidden">
            Start Game
          </button>
        </div>
      </div>
    </div>

    <!-- Table / Game Board -->
    <div id="table" class="hidden">
      <div class="table-board">
        <div class="table-slot-top"></div>
        <div class="table-slot-left"></div>
        <div class="table-slot-center">
          <div id="center" class="center-area"></div>
        </div>
        <div class="table-slot-right"></div>
        <div class="table-slot-bottom"></div>
      </div>
    </div>
  </main>

  <!-- Game Log -->
  <section id="game-log" class="game-log hidden">
    <h3>Game Log</h3>
    <div id="game-log-entries"></div>
  </section>

  <!-- Rules Modal -->
  <div id="rules-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="rules-modal-title">
    <div class="modal-content">
      <h2 id="rules-modal-title">How to Play TopÂ That!</h2>
      <button class="modal-close-button" aria-label="Close rules">&times;</button>
      <!-- â€¦ your rules list â€¦ -->
    </div>
  </div>

  <!-- Toast container -->
  <div id="toast-container"></div>
</body>
</html>
</file>

<file path="public/scripts/events.js">
// public/scripts/events.js
import * as state from './state.js';

import { renderGameState } from './render.js';

import {
  JOIN_GAME,
  PLAYER_JOINED,
  LOBBY,
  STATE_UPDATE,
  REJOIN,
  SPECIAL_CARD,
  NEXT_TURN,
  START_GAME,
  JOINED
} from '../src/shared/events.js';

document.addEventListener('DOMContentLoaded', () => {
  state.loadSession();

  state.socket.on('connect', () => {
    if (state.myId && state.currentRoom) {
      state.socket.emit(REJOIN, state.myId, state.currentRoom);
    } else {
      showLobbyForm();
    }
  });
  state.socket.on(JOINED, ({ id, roomId }) => {
    state.setMyId(id);
    state.setCurrentRoom(roomId);
    state.saveSession();
  });

  state.socket.on(PLAYER_JOINED, d => {
    // server returns array of player IDs
    // (no longer sets myId here)
  });

  state.socket.on(LOBBY, data => {
    showWaitingState(data.roomId, data.players.length, data.maxPlayers);
  });

  state.socket.on(STATE_UPDATE, s => {
    renderGameState(s);
    if (s.started) showGameTable();
  });

  state.socket.on('err', msg => {
    showError(msg);
  });  // UI hooks
  const createJoinBtn = state.$('create-join');
  if (createJoinBtn) {
    createJoinBtn.onclick = () => {
      const name = validateName();
      if (!name) return;
      state.socket.emit(JOIN_GAME, name);
      // Add TypeScript-friendly way to set disabled property
      if (createJoinBtn instanceof HTMLButtonElement) {
        createJoinBtn.disabled = true;
      }
    };
  }
  state.getCopyLinkBtn() && (state.getCopyLinkBtn().onclick = () => {
    navigator.clipboard.writeText(window.location.href);
  });
  state.getRulesButton() && (state.getRulesButton().onclick = () => openModal(state.getRulesModal()));
  document.querySelector('.modal-close-button')?.addEventListener('click', closeModal);
  state.getModalOverlay() && (state.getModalOverlay().onclick = closeModal);

  state.getBackToLobbyButton() && (state.getBackToLobbyButton().onclick = () => {
    sessionStorage.clear();
    showLobbyForm();
  });
  // Start Game button wiring
  const startGameBtn = document.getElementById('start-game-button');
  if (startGameBtn) {
    startGameBtn.onclick = () => {
      state.socket.emit(START_GAME);
      // Add TypeScript-friendly way to set disabled property
      if (startGameBtn instanceof HTMLButtonElement) {
        startGameBtn.disabled = true;
      }
    };
  }

  // Always hide modal and overlay on load
  state.getRulesModal().classList.add('hidden');
  state.getModalOverlay().classList.add('hidden');

  // Show rules modal only when button is clicked
  const rulesBtn = state.getRulesButton();
  if (rulesBtn) {
    rulesBtn.onclick = () => {
      state.getRulesModal().classList.remove('hidden');
      state.getModalOverlay().classList.remove('hidden');
    };
  }
  // Close modal on close button or overlay click
  const closeBtn = document.querySelector('#rules-modal .modal-close-button');
  if (closeBtn && closeBtn instanceof HTMLButtonElement) {
    closeBtn.onclick = () => {
      state.getRulesModal().classList.add('hidden');
      state.getModalOverlay().classList.add('hidden');
    };
  } else if (closeBtn) {
    closeBtn.addEventListener('click', () => {
      state.getRulesModal().classList.add('hidden');
      state.getModalOverlay().classList.add('hidden');
    });
  }
  const overlay = state.getModalOverlay();
  if (overlay) {
    overlay.onclick = () => {
      state.getRulesModal().classList.add('hidden');
      state.getModalOverlay().classList.add('hidden');
    };
  }
});

// â€”â€“ UI helper functions â€”â€“

function validateName() {
  const nameIn    = state.$('name');
  const nameError = state.$('name-error');
  
  // TypeScript-friendly way to access input value
  const n = nameIn instanceof HTMLInputElement ? nameIn.value.trim() : '';
  
  if (!n) {
    nameIn.classList.add('input-error');
    nameError.classList.remove('hidden');
    return null;
  }
  nameError.classList.add('hidden');
  return n;
}

function showLobbyForm() {
  state.getLobbyContainer().classList.remove('hidden');
  state.getWaitingStateDiv().classList.add('hidden');
  state.getTable().classList.add('hidden');
  state.getLobbyFormContent().classList.remove('hidden');
}

function showWaitingState(roomId, current, max) {
  state.getLobbyContainer().classList.remove('hidden');
  state.getWaitingStateDiv().classList.remove('hidden');
  state.getLobbyFormContent().classList.add('hidden');
  state.$('waiting-heading').textContent = `Room ${roomId} (${current}/${max})`;
}

function showGameTable() {
  state.getLobbyContainer().classList.add('hidden');
  state.getTable().classList.remove('hidden');
}

function openModal(modalEl) {
  modalEl.classList.remove('hidden');
  state.getModalOverlay().classList.remove('hidden');
}

function closeModal() {
  state.getRulesModal().classList.add('hidden');
  state.getModalOverlay().classList.add('hidden');
}

function showError(msg) {
  const toast = document.createElement('div');
  toast.className = 'toast';
  toast.textContent = msg;
  state.$('toast-container')?.appendChild(toast);
  setTimeout(() => toast.remove(), 2000);
}

function showGameOverMessage(didWin, winnerName) {
  const over = document.createElement('div');
  over.id = 'game-over-container';
  over.innerHTML = `
    <div class="modal-content">
      <h1>Game Over!</h1>
      <p>${didWin ? 'ðŸŽ‰ You win!' : `${winnerName} wins!`}</p>
      <button id="play-again-btn" class="btn btn-primary">Play Again</button>
    </div>`;
  document.body.appendChild(over);
  state.$('play-again-btn')?.addEventListener('click', () => location.reload());
}
</file>

<file path="public/scripts/render.js">
// public/scripts/render.js
import { stateHistory, stateIndex, pileTransition } from './state.js';

// Convert {value:'A',suit:'hearts'} â†’ "AH", 10â†’"0"
function code(card) {
  if (card.back) return '';
  const v = String(card.value).toUpperCase() === '10' ? '0'
          : String(card.value).toUpperCase();
  const s = { hearts:'H', diamonds:'D', clubs:'C', spades:'S' }[card.suit];
  return v + s;
}

// Produce one <div class="card-container"><img class="card-img" â€¦></div>
export function cardImg(card, selectable, onLoad) {
  const container = document.createElement('div');
  container.className = 'card-container';

  const img = new Image();
  img.className = 'card-img';
  img.style.visibility = 'hidden';
  img.src = card.back
    ? 'https://deckofcardsapi.com/static/img/back.png'
    : `https://deckofcardsapi.com/static/img/${code(card)}.png`;
  img.alt = card.back ? 'Card back' : `${card.value} of ${card.suit}`;
  img.onload = () => {
    img.style.visibility = 'visible';
    if (onLoad) onLoad(img);
  };

  if (selectable) {
    img.classList.add('selectable');
    img.style.touchAction = 'manipulation';
    container.addEventListener('click', () => {
      img.classList.toggle('selected');
      container.classList.toggle('selected-container', img.classList.contains('selected'));
    });
  }

  container.appendChild(img);
  return container;
}

// Draw the deck + discard piles in the center
export function createCenterPiles(state) {
  const center = document.getElementById('center');
  center.innerHTML = '';

  const wrapper = document.createElement('div');
  wrapper.className = 'center-piles-wrapper';

  // Deck
  const deckC = document.createElement('div');
  deckC.className = 'center-pile-container';
  deckC.innerHTML = `<div class="pile-label">Deck (${state.deckCount})</div>`;
  const deckP = document.createElement('div');
  deckP.className = 'deck pile';
  if (state.deckCount > 0) deckP.appendChild(cardImg({ back:true }, false));
  deckC.appendChild(deckP);

  // Discard
  const discC = document.createElement('div');
  discC.className = 'center-pile-container';
  discC.innerHTML = `<div class="pile-label">Discard (${state.discardCount})</div>`;
  const discP = document.createElement('div');
  discP.className = 'discard pile';
  if (state.playPile.length)
    discP.appendChild(cardImg(state.playPile[state.playPile.length-1], false));
  discC.appendChild(discP);

  wrapper.append(deckC, discC);
  center.appendChild(wrapper);
}

// Main render entry: clear everything, seat players, then center piles.
export function renderGameState(s) {
  // 1) clear all four slots
  ['.table-slot-top','.table-slot-left','.table-slot-right','.table-slot-bottom']
    .forEach(sel => {
      const slot = document.querySelector(sel);
      if (slot) slot.innerHTML = '';
    });

  // 2) seat assignment, create each player panel, render hand/up/down, buttons
  //    â€¦ you can copy your existing code exactly here â€¦

  // 3) finally draw center piles
  createCenterPiles(s);
}
</file>

<file path="public/scripts/state.js">
// public/scripts/state.js
export const socket = io({
  reconnection:      true,
  reconnectionDelay: 1000,
  reconnectionDelayMax: 10000
});

export let myId        = null;
export let currentRoom = null;
export let pileTransition       = false;
export let specialEffectsQueue  = [];
export let processingEffects    = false;

export const stateHistory = [];
export let   stateIndex   = -1;

// handy DOMâ€‘byâ€‘ID shortcut
/**
 * @param {string} id
 * @returns {HTMLElement}
 */
export const $ = id => document.getElementById(id);

// DOM element getter functions - called only when needed
export const getLobbyContainer = () => $('lobby-container');
export const getLobbyFormContent = () => $('lobby-form-content');
export const getWaitingStateDiv = () => $('waiting-state');
export const getTable = () => $('table');
export const getCopyLinkBtn = () => $('copy-link-button');
export const getRulesButton = () => $('rules-button');
export const getRulesModal = () => $('rules-modal');
export const getModalOverlay = () => $('modal-overlay');
export const getBackToLobbyButton = () => $('back-to-lobby-button');
export const getGameLogEntries = () => $('game-log-entries');

export function loadSession() {
  setMyId(sessionStorage.getItem('myId'));
  setCurrentRoom(sessionStorage.getItem('currentRoom'));
}

export function saveSession() {
  sessionStorage.setItem('myId', myId);
  sessionStorage.setItem('currentRoom', currentRoom);
}

export function setMyId(id) { myId = id; }
export function setCurrentRoom(room) { currentRoom = room; }
export function setPileTransition(value) { pileTransition = value; }
export function setProcessingEffects(value) { processingEffects = value; }
export function addSpecialEffect(effect) { specialEffectsQueue.push(effect); }
export function clearSpecialEffects() { specialEffectsQueue = []; }
export function setStateIndex(index) { stateIndex = index; }
</file>

<file path="public/style.css">
/* filepath: c:\Users\chris\OneDrive\Documents\GitHub\Top-That-Refactor\public\style.css */

/* ========== Color Variables & Root Styles ========== */
:root {
  --bg: #0b5137; /* Main background dark green */
  --header-bg: #1b2e3c; /* Blue for header */
  --accent: #FFC300; /* Bright gold */
  --accent2: #4a90e2; /* Second Blue */
  --name: #FFC300; /* Bright gold for name */
  --text: #f5f5f5;
  --mute: #b0bec5; /* Muted Gray */
  --panelBorder: #ffffff22;
  --active-border: #00CCCC; /* Brighter teal */

  /* Card & UI colors */
  --card-bg: #ffffff;
  --card-text: #333333;
  --input-border: #cfd8dc; /* Light Gray */
  --placeholder-text: #78909c; /* Darkened for AA contrast */
  --error-color: #e53935; /* For validation */
  --btn-primary-bg: var(--accent);
  --btn-primary-text: #000000;
  --btn-secondary-bg: var(--accent); /* Match the gold color */
  --btn-secondary-text: #ffffff;
  --btn-tertiary-bg: #78909c; /* For Copy Link */
  --btn-tertiary-text: #ffffff;
  --body-bg-start: #367347; /* Gradient start to match main bg */
  --body-bg-mid: #2e5e3c;  /* Slightly darker for middle */
  --body-bg-end: #264c32;  /* Even darker for end */
  --overlay-bg: rgba(0, 0, 0, 0.6); /* Overlay background */

  /* Sizing */
  --header-height: 70px; /* Approximate height */
  --gutter: 24px;

  /* Card dimensions */
  --card-w: 67.2px;
  --card-h: 92.4px;
  --card-peek: calc(var(--card-h) * 0.2);

  /* Z-index layers for predictable stacking */
  --z-base: 1;
  --z-card: 10;
  --z-card-hover: 20;
  --z-card-selected: 30;
  --z-card-icon: 100;
  --z-ui-elements: 200;
  --z-tutorial: 500;
  --z-modal: 1000;
  --z-toast: 2000;
  --z-game-over: 3000;
}

/* ========== Base Styles ========== */
* { box-sizing: border-box; margin: 0; padding: 0; }
html, body {
  height: 100%;
  font-family: sans-serif;
  color: var(--text);
}
body {
  background: var(--bg);
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  padding-top: var(--header-height);
  margin: 0;
  overflow-y: auto;
}

/* ========== Header ========== */
#main-header {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: var(--header-height);
  background: var(--header-bg);
  border-bottom: 2px solid var(--panelBorder);
  display: flex; align-items: center; justify-content: center;
  z-index: var(--z-ui-elements);
}
.header-content {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%; max-width: 1200px;
  padding: 0 1.5rem;
}

/* ========== Buttons ========== */
.btn {
  padding: 8px 16px;
  border: none; border-radius: 4px;
  cursor: pointer; font-weight: bold;
  margin: 0 4px; z-index: var(--z-ui-elements);
}
.btn-primary {
  background-color: var(--btn-primary-bg);
  color: var(--btn-primary-text);
}
.btn-secondary {
  background-color: var(--btn-secondary-bg);
  color: var(--btn-secondary-text);
}
.btn-tertiary {
  background-color: var(--btn-tertiary-bg);
  color: var(--btn-tertiary-text);
}

/* ========== Lobby/Data UI ========== */
#lobby-container {
  max-width: 500px;
  margin: 80px auto;
  padding: 20px;
  background: var(--card-bg);
  color: var(--card-text);
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}
.form-group { margin-bottom: 16px; }
.form-group label { display: block; margin-bottom: 4px; font-weight: bold; }
.form-group input {
  width: 100%; padding: 8px;
  border: 1px solid var(--input-border);
  border-radius: 4px;
  color: var(--card-text);
  background-color: var(--card-bg);
}
.form-group input::placeholder {
  color: var(--placeholder-text);
}
.form-group input.input-error {
  border-color: var(--error-color);
}
.error-message { color: var(--error-color); font-size: 0.9em; margin-top: 4px; }

#waiting-state {
  text-align: center;
  border-top: 1px solid var(--input-border);
}
.spinner { margin: 16px auto; }
.spinner > div {
  background-color: var(--accent2);
}

/* ========== Table/Game Board ========== */
#table {
  display: grid; place-items: center;
  background-color: #27ae60;
  border-radius: 50%;
  width: 100%;
  height: calc(100vh - var(--header-height));
  z-index: var(--z-base);
}

/* ========== Card Imagery ========== */
.card-img {
  width: var(--card-w);
  height: var(--card-h);
  object-fit: contain;
  border-radius: 5px;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}
.special-card-pulse {
  animation: specialCardPulse 0.8s ease-in-out;
  position: relative;
  z-index: var(--z-base);
}
.regular-card-glow {
  animation: regularCardGlow 1.5s ease-in-out;
  position: relative;
  z-index: var(--z-base);
}
@keyframes specialCardPulse {
  0% { box-shadow: 0 0 0 0 rgba(255,255,255,0.8); transform: scale(1); }
  25% { box-shadow: 0 0 0 10px rgba(255,255,255,0.4); transform: scale(1.05); }
  50% { box-shadow: 0 0 0 15px rgba(255,255,255,0.2); transform: scale(1.08); }
  75% { box-shadow: 0 0 0 10px rgba(255,255,255,0.1); transform: scale(1.05); }
 100% { box-shadow: 0 0 0 0 rgba(255,255,255,0); transform: scale(1); }
}
@keyframes regularCardGlow {
  0% { box-shadow: 0 0 0 0 rgba(255,255,255,0.4); }
 50% { box-shadow: 0 0 15px 5px rgba(255,255,255,0.6); }
 100% { box-shadow: 0 0 0 0 rgba(255,255,255,0.4); }
}

/* ========== Modals & Toasts ========== */
#modal-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0, 0, 0, 0.3); /* More transparent overlay */
  z-index: var(--z-modal);
  pointer-events: auto;
}
.modal-nonblocking {
  pointer-events: none; /* Allow clicks through overlay */
}
.modal-nonblocking .modal-content {
  pointer-events: auto; /* Modal itself is still interactive */
}
.modal-content {
  position: fixed;
  top: 50%; left: 50%; transform: translate(-50%,-50%);
  background: var(--card-bg);
  color: var(--card-text);
  padding: 20px;
  border-radius: 8px;
  z-index: calc(var(--z-modal) + 1);
  max-width: 400px;
  box-shadow: 0 8px 32px 0 rgba(0,0,0,0.25), 0 1.5px 6px 0 var(--accent2);
  border: 2px solid var(--accent2);
}
.modal-close-button {
  position: absolute;
  top: 8px; right: 8px;
  background: none; border: none;
  font-size: 24px; cursor: pointer;
  color: var(--accent);
}
.modal-close-button:hover {
  color: var(--text);
}

#toast-container {
  position: fixed;
  bottom: 20px; right: 20px;
  z-index: var(--z-toast);
}
.toast {
  background: rgba(0,0,0,0.85);
  color: #ffffff;
}

#rules-modal {
  background-color: #0c3d2a;
  color: var(--text);
  border: 2px solid var(--accent);
}
#rules-modal-title {
  color: var(--accent);
  border-bottom: 1px solid rgba(255, 195, 0, 0.3);
}
#rules-modal .modal-close-button {
  color: var(--accent);
}
#rules-modal .modal-close-button:hover {
  color: var(--text);
}
#rules-modal > .modal-content > ul > li {
  color: var(--accent);
}
#rules-modal .sublist {
  color: var(--card-bg);
}

.banner {
  background: var(--accent2);
  color: #fff;
}
.error-banner {
  background: linear-gradient(90deg, var(--body-bg-mid) 80%, var(--body-bg-start) 100%);
  color: #fffbe7;
  border: 2.5px solid var(--accent);
  box-shadow: 0 4px 18px 0 #0005, 0 0 0 2px #FFC30055;
}
.took-pile-banner {
  background: #ffd36b;
  color: #222;
}

.pile {
  background-color: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

#event-banner {
  color: var(--text);
}
.event-banner-visible.burn {
  background-color: #ff4500;
}
.event-banner-visible.reset {
  background-color: #4caf50;
}
.event-banner-visible.copy {
  background-color: #2196f3;
}

.button-container {
  background: none !important;
  border: none !important;
  box-shadow: none !important;
}
#play, #take {
  background: var(--btn-primary-bg);
  color: var(--btn-primary-text);
}
#join-computer {
  background: var(--accent2);
  color: #fff;
}

.special-icon {
  z-index: var(--z-card-icon);
}

#game-log {
  background: var(--card-bg);
  border: 1px solid var(--input-border);
}
</file>

<file path="server.js">
// server.js (ES module format)

import express from 'express';
import http from 'http';
import { Server } from 'socket.io';
import GameController from './controllers/GameController.js';

const app = express();
const server = http.createServer(app);

// Allow any origin for dev; lock down in production
const io = new Server(server, { cors: { origin: '*' } });

// Serve your client files from /public
app.use(express.static('public'));

// Also serve the src directory for shared modules
app.use('/src', express.static('src'));

// Rooms are autoâ€‘created by socket.join(roomId) in GameController
// No explicit setupRoom call required.

// Instantiate your game controller (it wires up all socket events)
new GameController(io);

// Start listening
const PORT = 3002; // Hard-code port to avoid conflicts
server.listen(PORT, () => {
  console.log(`ðŸƒ Top That! server running at http://localhost:${PORT}`);
});

// Optional HTTP error handling
server.on('error', err => {
  console.error('Server failed to start:', err);
});
</file>

<file path="tests/cardUtils.test.js">
// tests/cardUtils.test.js

import {
  normalizeCardValue,
  rank,
  isTwoCard,
  isFiveCard,
  isTenCard,
  isSpecialCard,
  isFourOfAKind
} from '../utils/cardUtils.js';

describe('cardUtils', () => {
  describe('normalizeCardValue', () => {
    it('maps 2 variants to "two"', () => {
      expect(normalizeCardValue(2)).toBe('two');
      expect(normalizeCardValue('2')).toBe('two');
      expect(normalizeCardValue('two')).toBe('two');
    });
    it('maps 5 variants to "five"', () => {
      expect(normalizeCardValue(5)).toBe('five');
      expect(normalizeCardValue('Five')).toBe('five');
    });
    it('maps 10 variants to "ten"', () => {
      expect(normalizeCardValue(10)).toBe('ten');
      expect(normalizeCardValue('TEN')).toBe('ten');
    });
    it('lowercases other strings', () => {
      expect(normalizeCardValue('Jack')).toBe('jack');
      expect(normalizeCardValue('Q')).toBe('q');
    });
    it('returns falsy as-is', () => {
      expect(normalizeCardValue(null)).toBeNull();
      expect(normalizeCardValue(undefined)).toBeUndefined();
    });
  });

  describe('rank', () => {
    it('returns numeric rank for special cards', () => {
      expect(rank({ value: 'two' })).toBe(2);
      expect(rank({ value: 5 })).toBe(5);
      expect(rank({ value: 'TEN' })).toBe(10);
    });
    it('returns face-card ranks', () => {
      expect(rank({ value: 'J' })).toBe(11);
      expect(rank({ value: 'q' })).toBe(12);
      expect(rank({ value: 'K' })).toBe(13);
      expect(rank({ value: 'a' })).toBe(14);
    });
    it('parses numeric strings', () => {
      expect(rank({ value: '3' })).toBe(3);
      expect(rank({ value: 7 })).toBe(7);
    });
  });

  describe('isTwoCard/isFiveCard/isTenCard', () => {
    it('correctly identifies each special card type', () => {
      expect(isTwoCard('2')).toBe(true);
      expect(isFiveCard(5)).toBe(true);
      expect(isTenCard('Ten')).toBe(true);
      expect(isTwoCard('five')).toBe(false);
    });
  });

  describe('isSpecialCard', () => {
    it('is true for any special card', () => {
      ['2','5','10','two','five','TEN'].forEach(v => {
        expect(isSpecialCard(v)).toBe(true);
      });
      expect(isSpecialCard('3')).toBe(false);
    });
  });

  describe('isFourOfAKind', () => {
    it('returns true for 4 of the same value', () => {
      const hand = [
        { value: 'Q' },
        { value: 'q' },
        { value: 'Q' },
        { value: 'Q' }
      ];
      expect(isFourOfAKind(hand)).toBe(true);
    });
    it('returns false for mixed values or wrong length', () => {
      expect(isFourOfAKind([{ value: '5' }, { value: '5' }, { value: '5' }])).toBe(false);
      expect(isFourOfAKind([{ value: '5' },{ value: '5' },{ value: 'two' },{ value: '5' }])).toBe(false);
    });
  });
});
</file>

<file path="tests/gameState.test.js">
// tests/gameState.test.js

import GameState from '../models/GameState.js';

describe('GameState', () => {
  let gs;
  beforeEach(() => {
    gs = new GameState();
  });

  test('initializes with empty players, pile, discard and index 0', () => {
    expect(gs.players).toEqual([]);
    expect(gs.currentPlayerIndex).toBe(0);
    expect(gs.pile).toEqual([]);
    expect(gs.discard).toEqual([]);
  });

  test('addPlayer adds to players array', () => {
    gs.addPlayer('alice');
    gs.addPlayer('bob');
    expect(gs.players).toEqual(['alice', 'bob']);
  });

  test('advancePlayer cycles through players', () => {
    gs.addPlayer('p1');
    gs.addPlayer('p2');
    expect(gs.currentPlayerIndex).toBe(0);

    gs.advancePlayer();
    expect(gs.currentPlayerIndex).toBe(1);

    gs.advancePlayer();
    expect(gs.currentPlayerIndex).toBe(0);
  });

  test('addToPile pushes cards onto pile', () => {
    const cardA = { value: '3' };
    const cardB = { value: '5' };
    gs.addToPile(cardA);
    gs.addToPile(cardB);
    expect(gs.pile).toEqual([cardA, cardB]);
  });

  test('clearPile moves pile into discard and empties pile', () => {
    const c1 = { value: '7' };
    const c2 = { value: '8' };
    gs.addToPile(c1);
    gs.addToPile(c2);

    gs.clearPile();
    expect(gs.pile).toEqual([]);
    expect(gs.discard).toEqual([c1, c2]);
  });
});
</file>

<file path="tests/player.test.js">
// tests/player.test.js

import Player from '../models/Player.js';

describe('Player model', () => {
  let p;
  beforeEach(() => {
    p = new Player('p1');
  });

  test('initial state', () => {
    expect(p.id).toBe('p1');
    expect(p.hand).toEqual([]);
    expect(p.upCards).toEqual([]);
    expect(p.downCards).toEqual([]);
  });

  test('setHand & sortHand', () => {
    const c3 = { value: '3' };
    const c2 = { value: '2' };
    const c5 = { value: '5' };
    p.setHand([c3, c5, c2]);
    expect(p.hand).toEqual([c2, c3, c5]);
  });

  test('playFromHand removes and returns the card', () => {
    const card = { value: '7' };
    p.setHand([card]);
    const played = p.playFromHand(0);
    expect(played).toBe(card);
    expect(p.hand).toEqual([]);
  });

  test('setUpCards & playUpCard', () => {
    const u = [{ value: '4' }, { value: 'J' }];
    p.setUpCards(u);
    const played = p.playUpCard(1);
    expect(played).toEqual(u[1]);
    expect(p.upCards).toEqual([u[0]]);
  });

  test('setDownCards & playDownCard', () => {
    jest.spyOn(Math, 'random').mockReturnValue(0.7);
    const d = [{ value: '8' }, { value: '9' }, { value: '10' }];
    p.setDownCards(d);
    const played = p.playDownCard();
    expect(played).toEqual(d[2]);
    expect(p.downCards).toEqual([d[0], d[1]]);
    Math.random.mockRestore();
  });

  test('pickUpPile adds and sorts', () => {
    const pile = [{ value: 'K' }, { value: '2' }];
    p.pickUpPile(pile);
    expect(p.hand[0].value).toBe('2');
    expect(p.hand[1].value).toBe('K');
  });

  test('hasEmpty... helpers', () => {
    expect(p.hasEmptyHand()).toBe(true);
    expect(p.hasEmptyUp()).toBe(true);
    expect(p.hasEmptyDown()).toBe(true);
    p.setHand([{ value: '3' }]);
    p.setUpCards([{ value: '4' }]);
    p.setDownCards([{ value: '5' }]);
    expect(p.hasEmptyHand()).toBe(false);
    expect(p.hasEmptyUp()).toBe(false);
    expect(p.hasEmptyDown()).toBe(false);
  });
});
</file>

<file path="utils/cardUtils.js">
// utils/cardUtils.js - ES Module version

/**
 * Normalizes card values to consistent strings.
 * '2', 2 -> 'two'
 * '5', 5 -> 'five'
 * '10', 10 -> 'ten'
 * Other numeric strings/numbers are returned as strings.
 * Other strings are lowercased.
 * Falsy values are returned as-is.
 * @param {string | number | null | undefined} cardValue
 * @returns {string | null | undefined}
 */
export function normalizeCardValue(cardValue) {
  if (!cardValue && cardValue !== 0) {
    // Handle null and undefined explicitly for TypeScript satisfaction
    // @ts-ignore - This will be either null or undefined
    return cardValue;
  }
  const lowerVal = String(cardValue).toLowerCase();
  if (lowerVal === '2' || lowerVal === 'two') return 'two';
  if (lowerVal === '5' || lowerVal === 'five') return 'five';
  if (lowerVal === '10' || lowerVal === 'ten') return 'ten';
  return lowerVal;
}

/**
 * Returns the numeric rank of a card.
 * Special cards 'two', 'five', 'ten' have their respective numeric values.
 * Face cards J, Q, K, A are 11, 12, 13, 14.
 * Other numeric cards are parsed.
 * @param {{ value: string | number }} card
 * @returns {number}
 */
export function rank(card) {
  const val = normalizeCardValue(card.value);
  switch (val) {
    case 'two': return 2;
    case 'five': return 5;
    case 'ten': return 10;
    case 'j': case 'jack': return 11;
    case 'q': case 'queen': return 12;
    case 'k': case 'king': return 13;
    case 'a': case 'ace': return 14;
    default: return parseInt(val, 10);
  }
}

/**
 * Checks if a card is a 'Two'.
 * @param {string|number} cardValue
 * @returns {boolean}
 */
export function isTwoCard(cardValue) {
  return normalizeCardValue(cardValue) === 'two';
}

/**
 * Checks if a card is a 'Five'.
 * @param {string|number} cardValue
 * @returns {boolean}
 */
export function isFiveCard(cardValue) {
  return normalizeCardValue(cardValue) === 'five';
}

/**
 * Checks if a card is a 'Ten'.
 * @param {string|number} cardValue
 * @returns {boolean}
 */
export function isTenCard(cardValue) {
  return normalizeCardValue(cardValue) === 'ten';
}

/**
 * Checks if a card value corresponds to a special card (Two, Five, or Ten).
 * @param {string|number} cardValue
 * @returns {boolean}
 */
export function isSpecialCard(cardValue) {
  const normalized = normalizeCardValue(cardValue);
  return normalized === 'two' || normalized === 'five' || normalized === 'ten';
}

/**
 * Checks if a hand (array of cards) represents four of a kind.
 * @param {Array<{ value: string|number }>} hand
 * @returns {boolean}
 */
export function isFourOfAKind(hand) {
  if (!hand || hand.length !== 4) {
    return false;
  }
  const firstValue = normalizeCardValue(hand[0].value);
  return hand.every(card => normalizeCardValue(card.value) === firstValue);
}

// Default export with named exports
export default { normalizeCardValue, rank };
</file>

<file path="controllers/GameController.js">
// controllers/GameController.js

/**
 * GAME CONTROLLER
 * - Isolate game logic from Socket.IO networking.
 * - Normalize all card values via cardUtils.normalizeCardValue().
 * - Emit 'card-played' â†’ optionally emit 'special-card' for ['two','five','ten'].
 * - Next turn only starts after client emits 'start-next-turn'.
 */
import GameState from '../models/GameState.js';
import Player from '../models/Player.js';
import { normalizeCardValue, isSpecialCard } from '../utils/cardUtils.js';
import {
  JOIN_GAME,
  JOINED,
  PLAYER_JOINED,
  LOBBY,
  STATE_UPDATE,
  SPECIAL_CARD,
  REJOIN,
  START_GAME,
  NEXT_TURN
} from '../src/shared/events.js';

export default class GameController {
  /**
   * @param {import('socket.io').Server} io
   */
  constructor(io) {
    this.io = io;
    this.gameState = new GameState();
    this.players = new Map(); // Map<playerId, Player>

    // Wire up perâ€‘socket listeners
    this.io.on('connection', socket => this.setupListeners(socket));
  }

  /**
   * Register socket event handlers
   * @param {import('socket.io').Socket} socket
   */
  setupListeners(socket) {
    socket.on(JOIN_GAME, playerId => this.handleJoin(socket, playerId));
    socket.on(START_GAME, () => this.handleStartGame());
    socket.on('play-card', data => this.handlePlay(socket, data));
    socket.on(NEXT_TURN, () => this.handleNextTurn());
    socket.on(REJOIN, ({ roomId, playerId }) => {
      // Validate the room exists (for now, only 'game-room' is valid)
      if (roomId !== 'game-room' || !this.players.has(playerId)) {
        socket.emit('err', 'Invalid room or player for rejoin');
        return;
      }
      socket.join(roomId);
      // Resend the latest game snapshot
      const state = {
        players: this.gameState.players.map(id => ({
          id,
          handCount: this.players.get(id).hand.length,
          upCount: this.players.get(id).upCards.length,
          downCount: this.players.get(id).downCards.length,
        })),
        pile: this.gameState.pile,
        discardCount: this.gameState.discard.length,
        currentPlayer: this.gameState.players[this.gameState.currentPlayerIndex],
      };
      socket.emit(STATE_UPDATE, state);
    });
  }

  /** Add a new player to the game */
  handleJoin(socket, playerId) {
    if (this.players.has(playerId)) {
      socket.emit('err', 'Player already joined');
      return;
    }
    this.gameState.addPlayer(playerId);
    const player = new Player(playerId);
    this.players.set(playerId, player);

    socket.join('game-room');
    // One-off ACK to the joining socket
    socket.emit(JOINED, { id: playerId, roomId: 'game-room' });
    // Notify all clients of the updated player list
    const playerList = [...this.players.keys()];
    this.io.to('game-room').emit(PLAYER_JOINED, playerList);
    this.io.to('game-room').emit(LOBBY, {
      roomId: 'game-room',
      players: playerList,
      maxPlayers: 4
    });
    this.pushState();
  }

  /** Initialize deck, deal cards, assign them to players, and emit first turn */
  handleStartGame() {
    if (this.players.size < 2) return;
    this.gameState.buildDeck();
    // Deal cards to all players
    const numPlayers = this.gameState.players.length;
    const { hands, upCards, downCards } = this.gameState.dealCards(numPlayers);
    // Assign cards to each player
    this.gameState.players.forEach((id, idx) => {
      const player = this.players.get(id);
      player.setHand(hands[idx]);
      player.setUpCards(upCards[idx]);
      player.setDownCards(downCards[idx]);
    });
    this.pushState();
    const first = this.gameState.players[0];
    this.io.to('game-room').emit(NEXT_TURN, first);
  }

  /**
   * Player plays a card from hand/up/down
   * @param {import('socket.io').Socket} socket
   * @param {{playerId:string,cardIndex:number,zone:'hand'|'up'|'down'}} data
   */
  handlePlay(socket, { playerId, cardIndex, zone }) {
    const player = this.players.get(playerId);
    if (!player) return;

    let card;
    switch (zone) {
      case 'hand': card = player.playFromHand(cardIndex); break;
      case 'up':   card = player.playUpCard(cardIndex);     break;
      case 'down': card = player.playDownCard();            break;
      default:     return;
    }

    const normalized = normalizeCardValue(card.value);
    this.gameState.addToPile({ ...card, value: normalized });
    this.io.to('game-room').emit('card-played', { playerId, card: { ...card, value: normalized } });

    if (isSpecialCard(normalized)) {
      socket.emit(SPECIAL_CARD, normalized);
    }
  }

  /** Advance to next player's turn */
  handleNextTurn() {
    this.gameState.advancePlayer();
    const next = this.gameState.players[this.gameState.currentPlayerIndex];
    this.io.to('game-room').emit(NEXT_TURN, next);
  }

  /** Cleanup on disconnect (optional) */
  handleDisconnect(socket) {
    // TO DO: remove or mark offline
    this.pushState();
  }

  /** Broadcast full game state to all clients */
  pushState() {
    const state = {
      players: this.gameState.players.map(id => ({
        id,
        handCount: this.players.get(id).hand.length,
        upCount: this.players.get(id).upCards.length,
        downCount: this.players.get(id).downCards.length,
      })),
      pile: this.gameState.pile,
      discardCount: this.gameState.discard.length,
      currentPlayer: this.gameState.players[this.gameState.currentPlayerIndex],
    };
    this.io.to('game-room').emit(STATE_UPDATE, state);
  }
}
</file>

<file path="package.json">
{
  "name": "top-that-refactor",
  "version": "1.0.0",
  "description": "Refactored Top That! card game server and utilities",
  "main": "server.js",
  "type": "module",
  "scripts": {
    "start": "node server.js",
    "test": "jest"
  },
  "dependencies": {
    "express": "^4.18.2",
    "socket.io": "^4.7.2"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/preset-env": "^7.27.2",
    "@types/jest": "^29.5.14",
    "babel-jest": "^29.7.0",
    "jest": "^29.6.1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
</file>

<file path="models/GameState.js">
// models/GameState.js

/**
 * GAME STATE
 * Manages the core game data: players, turn order, pile, and discard.
 */
export default class GameState {
  constructor() {
    /** @type {string[]} List of player IDs in turn order */
    this.players = [];
    /** @type {number} Index of the current player in `players` */
    this.currentPlayerIndex = 0;
    /** @type {object[]} Cards played into the current pile */
    this.pile = [];
    /** @type {object[]} All cards that have been cleared from the pile */
    this.discard = [];
  }

  /**
   * Add a player to the game.
   * @param {string} playerId
   */
  addPlayer(playerId) {
    this.players.push(playerId);
  }

  /**
   * Advance currentPlayerIndex to the next player in the queue,
   * wrapping back to 0 at the end.
   */
  advancePlayer() {
    if (this.players.length === 0) return;
    this.currentPlayerIndex =
      (this.currentPlayerIndex + 1) % this.players.length;
  }

  /**
   * Add a card to the current pile.
   * @param {object} card
   */
  addToPile(card) {
    this.pile.push(card);
  }

  /**
   * Clear the current pile:
   * - Move all pile cards into `discard`
   * - Reset `pile` to an empty array
   */
  clearPile() {
    this.discard.push(...this.pile);
    this.pile = [];
  }

  /**
   * Build a standard 52-card deck and shuffle it (Fisherâ€“Yates).
   */
  buildDeck() {
    const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
    const values = [2, 3, 4, 5, 6, 7, 8, 9, 10, 'J', 'Q', 'K', 'A'];
    this.deck = [];
    for (const suit of suits) {
      for (const value of values) {
        this.deck.push({ value, suit });
      }
    }
    for (let i = this.deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
    }
  }

  /**
   * Deal cards to players: hand, upCards, downCards for each.
   * @param {number} numPlayers
   * @param {number} handSize
   * @returns {{ hands: object[][], upCards: object[][], downCards: object[][] }}
   */
  dealCards(numPlayers, handSize = 3) {
    const hands = [];
    const upCards = [];
    const downCards = [];
    for (let p = 0; p < numPlayers; p++) {
      hands.push(this.deck.splice(0, handSize));
      upCards.push(this.deck.splice(0, handSize));
      downCards.push(this.deck.splice(0, handSize));
    }
    return { hands, upCards, downCards };
  }
}
</file>

<file path="models/Player.js">
// models/Player.js

import { rank } from '../utils/cardUtils.js';

/**
 * PLAYER
 * Manages a single playerâ€™s hand, upâ€‘cards, downâ€‘cards, and pickâ€‘up logic.
 */
export default class Player {
  /**
   * @param {string} id Unique player identifier
   */
  constructor(id) {
    /** @type {string} */
    this.id = id;
    /** @type {object[]} Cards in hand (visible) */
    this.hand = [];
    /** @type {object[]} Faceâ€‘up cards (visible after hand is empty) */
    this.upCards = [];
    /** @type {object[]} Faceâ€‘down cards (hidden until both hand & up are empty) */
    this.downCards = [];
  }

  /**
   * Replace this.hand with new cards and sort.
   * @param {object[]} cards
   */
  setHand(cards) {
    this.hand = [...cards];
    this.sortHand();
  }

  /**
   * Replace this.upCards.
   * @param {object[]} cards
   */
  setUpCards(cards) {
    this.upCards = [...cards];
  }

  /**
   * Replace this.downCards.
   * @param {object[]} cards
   */
  setDownCards(cards) {
    this.downCards = [...cards];
  }

  /**
   * Play a card from hand at index.
   * @param {number} index
   * @returns {object} the played card
   */
  playFromHand(index) {
    return this.hand.splice(index, 1)[0];
  }

  /**
   * Play a faceâ€‘up card at index.
   * @param {number} index
   * @returns {object}
   */
  playUpCard(index) {
    return this.upCards.splice(index, 1)[0];
  }

  /**
   * Play a random faceâ€‘down card.
   * @returns {object}
   */
  playDownCard() {
    const idx = Math.floor(Math.random() * this.downCards.length);
    return this.downCards.splice(idx, 1)[0];
  }

  /**
   * When picking up the pile, add those cards into hand and reâ€‘sort.
   * @param {object[]} pile
   */
  pickUpPile(pile) {
    this.hand.push(...pile);
    this.sortHand();
  }

  /** Sort hand lowestâ†’highest by rank */
  sortHand() {
    this.hand.sort((a, b) => rank(a) - rank(b));
  }

  /** @returns {boolean} true if hand is empty */
  hasEmptyHand() {
    return this.hand.length === 0;
  }

  /** @returns {boolean} true if upCards is empty */
  hasEmptyUp() {
    return this.upCards.length === 0;
  }

  /** @returns {boolean} true if downCards is empty */
  hasEmptyDown() {
    return this.downCards.length === 0;
  }
}
</file>

</files>
