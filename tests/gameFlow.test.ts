import { jest, describe, test, beforeEach, expect } from '@jest/globals';

import GameController from '../controllers/GameController.js';
import GameState from '../models/GameState.js';
import { JoinGamePayload } from '../src/shared/types.js';

// Use string literals for event names to avoid import errors
const JOINED = 'joined';
const LOBBY = 'lobby';
const STATE_UPDATE = 'state-update';
const NEXT_TURN = 'next-turn';
const ERROR_EVENT = 'error-event';

// --- Type Definitions for Mocks ---
interface MockSocket {
  id: string;
  join: any;
  emit: any;
  on: any;
  removeAllListeners: any;
  eventHandlers: Record<string, (data?: any, ack?: Function) => void>;
  simulateIncomingEvent: (event: string, data?: any, ack?: Function) => void;
  disconnect?: any;
}

interface MockIOWithEmit {
  emit: any;
}

interface MockIO {
  on: any;
  to: any;
  emit: any;
  sockets: {
    sockets: Map<string, MockSocket>;
  };
}

// Add a type for state payloads emitted in tests
interface StatePayload {
  players: any[];
  currentPlayerId: string;
  started: boolean;
}

// --- Mock Implementations ---
let globalMockSocket: MockSocket;

const topLevelEmitMock = jest.fn();

const mockIo: MockIO = {
  on: jest.fn((event: string, handler: (socket: MockSocket) => void) => {
    if (event === 'connection') {
      if (globalMockSocket && mockIo.sockets && mockIo.sockets.sockets) {
        mockIo.sockets.sockets.set(globalMockSocket.id, globalMockSocket);
      }
      if (handler && globalMockSocket) {
        handler(globalMockSocket);
      }
    }
  }),
  to: jest.fn(function (_id: string): MockIOWithEmit {
    const specificEmitMock = jest.fn((event: string, payload?: any) => {
      topLevelEmitMock(event, payload);
    });
    return { emit: specificEmitMock };
  }),
  emit: jest.fn((event: string, payload?: any) => {
    topLevelEmitMock(event, payload);
  }),
  sockets: {
    sockets: new Map<string, MockSocket>(),
  },
};

describe('Game Flow - Single Player vs CPU (manual start)', () => {
  let gameController: GameController;

  beforeEach(() => {
    topLevelEmitMock.mockClear();

    globalMockSocket = {
      id: 'socket-id-1',
      join: jest.fn(),
      emit: jest.fn((event: string, payload?: any) => {
        topLevelEmitMock(event, payload);
      }),
      on: jest.fn((event: string, handler: (data?: any, ack?: Function) => void) => {
        globalMockSocket.eventHandlers[event as string] = handler;
      }),
      removeAllListeners: jest.fn(),
      eventHandlers: {},
      simulateIncomingEvent: (event, data, ack) => {
        if (globalMockSocket.eventHandlers[event as string]) {
          globalMockSocket.eventHandlers[event as string](data, ack);
        }
      },
      disconnect: jest.fn(),
    };

    if (mockIo.sockets && mockIo.sockets.sockets) {
      mockIo.sockets.sockets.clear();
      mockIo.sockets.sockets.set(globalMockSocket.id, globalMockSocket);
    }

    mockIo.on.mockClear();
    mockIo.to.mockClear();
    // Pass a dummy roomId for tests (required by GameController constructor)
    gameController = new GameController(mockIo as any, 'test-room');
  });

  test('Player joins and host starts game with 1 CPU, initial state is broadcast', () => {
    const joinPayload: JoinGamePayload = {
      playerName: 'Player1',
      numHumans: 1,
      numCPUs: 1,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(globalMockSocket, joinPayload);

    // Game should not auto-start for human vs CPU
    expect(gameController['gameState'].started).toBe(false);
    (gameController['handleStartGame'] as Function)({ computerCount: 1, socket: globalMockSocket });

    expect(gameController['gameState'].started).toBe(true);
    // Player IDs are now generated by the server, so check by name
    const player = Array.from(gameController['players'].values()).find(
      (p) => p.name === joinPayload.playerName
    );
    expect(player).toBeDefined();
    expect(gameController['players'].has('COMPUTER_1')).toBe(true);

    // After start, CPUs should be present and game should be started
    expect(gameController['gameState'].started).toBe(true);
    expect(gameController['players'].has('COMPUTER_1')).toBe(true);

    // Find the state update with started: true
    const stateUpdateAfterStart = topLevelEmitMock.mock.calls.find(
      (call) => call[0] === STATE_UPDATE && (call[1] as any)?.started === true
    );
    expect(stateUpdateAfterStart).toBeDefined();
    const emittedState = stateUpdateAfterStart![1] as any;
    expect(emittedState.players.length).toBe(2);
    // The first player is the human
    expect(emittedState.players.some((p: any) => p.name === joinPayload.playerName)).toBe(true);

    // Check that NEXT_TURN was emitted for the human
    const nextTurnArgs = topLevelEmitMock.mock.calls.find((call) => call[0] === NEXT_TURN);
    expect(nextTurnArgs).toBeDefined();
    // Check hands were dealt
    const playerInstance = Array.from(gameController['players'].values()).find(
      (p) => p.name === joinPayload.playerName
    );
    const cpu1Instance = gameController['players'].get('COMPUTER_1');
    expect(playerInstance && playerInstance.hand.length).toBe(3);
    expect(cpu1Instance && cpu1Instance.hand.length).toBe(3);
    expect(gameController['gameState'].deck!.length).toBe(52 - 2 * 9);
  });
});

describe('Game Flow - Lobby with Extra Human', () => {
  let gameController: GameController;

  beforeEach(() => {
    topLevelEmitMock.mockClear();

    globalMockSocket = {
      id: 'socket-lobby',
      join: jest.fn(),
      emit: jest.fn(),
      on: jest.fn(),
      removeAllListeners: jest.fn(),
      eventHandlers: {},
      simulateIncomingEvent: () => {},
      disconnect: jest.fn(),
    } as unknown as MockSocket;

    if (mockIo.sockets && mockIo.sockets.sockets) {
      mockIo.sockets.sockets.clear();
      mockIo.sockets.sockets.set(globalMockSocket.id, globalMockSocket);
    }

    mockIo.on.mockClear();
    mockIo.to.mockClear();
    gameController = new GameController(mockIo as any, 'test-room');
  });

  test('No auto-start when expecting another human', () => {
    const joinPayload: JoinGamePayload = {
      playerName: 'Host',
      numHumans: 2,
      numCPUs: 1,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(globalMockSocket, joinPayload);
    expect(gameController['gameState'].started).toBe(false);
    expect(gameController['players'].has('COMPUTER_1')).toBe(false);
  });
});

describe('Game Flow - Manual Start by Host', () => {
  let gameController: GameController;

  beforeEach(() => {
    topLevelEmitMock.mockClear();

    globalMockSocket = {
      id: 'host-socket-id',
      join: jest.fn(),
      emit: jest.fn((event: string, payload?: any) => {
        topLevelEmitMock(event, payload);
      }),
      on: jest.fn((event: string, handler: (data?: any, ack?: Function) => void) => {
        globalMockSocket.eventHandlers[event as string] = handler;
      }),
      removeAllListeners: jest.fn(),
      eventHandlers: {},
      simulateIncomingEvent: (event, data, ack) => {
        if (globalMockSocket.eventHandlers[event as string]) {
          globalMockSocket.eventHandlers[event as string](data, ack);
        }
      },
      disconnect: jest.fn(),
    };

    if (mockIo.sockets && mockIo.sockets.sockets) {
      mockIo.sockets.sockets.clear();
      mockIo.sockets.sockets.set(globalMockSocket.id, globalMockSocket);
    }

    mockIo.on.mockClear();
    mockIo.to.mockClear();
    topLevelEmitMock.mockClear();
    // Pass a dummy roomId for tests (required by GameController constructor)
    gameController = new GameController(mockIo as any, 'test-room');
  });

  test('Host joins (no auto-CPUs), Player2 joins, Host starts game (no explicit CPUs)', async () => {
    topLevelEmitMock.mockClear();

    const originalHostSocketId = globalMockSocket.id;
    if (mockIo.sockets.sockets.has(originalHostSocketId)) {
      mockIo.sockets.sockets.delete(originalHostSocketId);
    }

    globalMockSocket.id = 'socket-A';
    globalMockSocket.emit = jest.fn((event: string, payload?: any) => {
      topLevelEmitMock(event, payload);
    });
    // Ensure the GameController can find this socket by its new ID
    if (mockIo.sockets && mockIo.sockets.sockets) {
      // Ensure sockets map exists
      mockIo.sockets.sockets.set(globalMockSocket.id, globalMockSocket);
    }

    const playerAJoin: JoinGamePayload = {
      playerName: 'PlayerA',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(globalMockSocket, playerAJoin);
    // Check that a JOINED event with the correct payload was emitted (allowing for extra events)
    const joinedCallHost = globalMockSocket.emit.mock.calls.find(
      (call: any) =>
        call[0] === JOINED &&
        call[1]?.name === playerAJoin.playerName &&
        call[1]?.roomId === 'test-room'
    );
    expect(joinedCallHost).toBeDefined();
    // Player IDs are now generated, so check by name
    const playerA = Array.from(gameController['players'].values()).find(
      (p) => p.name === playerAJoin.playerName
    );
    expect(playerA).toBeDefined();
    let stateUpdateCallHost = topLevelEmitMock.mock.calls.find(
      (call: any) => call[0] === STATE_UPDATE && (call[1] as StatePayload)?.started === false
    );
    expect(stateUpdateCallHost).toBeDefined();
    if (stateUpdateCallHost)
      expect((stateUpdateCallHost[1] as StatePayload).players.length).toBe(1);
    // Only clear mocks after all assertions
    topLevelEmitMock.mockClear();
    globalMockSocket.emit.mockClear();

    const playerBJoinSocket: MockSocket = {
      id: 'socket-B',
      join: jest.fn(),
      emit: jest.fn((event: string, payload?: any) => {
        topLevelEmitMock(event, payload);
      }),
      on: jest.fn((event: string, handler: (data?: any, ack?: Function) => void) => {
        (playerBJoinSocket.eventHandlers as any)[event as string] = handler;
      }),
      removeAllListeners: jest.fn(),
      eventHandlers: {},
      simulateIncomingEvent: (event, data, ack) => {
        if ((playerBJoinSocket.eventHandlers as any)[event as string]) {
          (playerBJoinSocket.eventHandlers as any)[event as string](data, ack);
        }
      },
      disconnect: jest.fn(),
    };
    mockIo.sockets.sockets.set(playerBJoinSocket.id, playerBJoinSocket);

    const playerBJoin: JoinGamePayload = {
      playerName: 'PlayerB',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(playerBJoinSocket, playerBJoin);
    // Check that a JOINED event with the correct payload was emitted for player B
    const joinedCallB = playerBJoinSocket.emit.mock.calls.find(
      (call: any) =>
        call[0] === JOINED &&
        call[1]?.name === playerBJoin.playerName &&
        call[1]?.roomId === 'test-room'
    );
    expect(joinedCallB).toBeDefined();
    // Check both players are present by name
    const playerB = Array.from(gameController['players'].values()).find(
      (p) => p.name === playerBJoin.playerName
    );
    expect(playerB).toBeDefined();
    expect(Array.from(gameController['players'].values()).map((p) => p.name)).toEqual(
      expect.arrayContaining([playerAJoin.playerName, playerBJoin.playerName])
    );
    expect(topLevelEmitMock).toHaveBeenCalledWith(
      LOBBY,
      expect.objectContaining({
        players: expect.arrayContaining([
          expect.objectContaining({ name: playerAJoin.playerName }),
          expect.objectContaining({ name: playerBJoin.playerName }),
        ]),
      })
    );
    let stateUpdateCallPlayer2 = topLevelEmitMock.mock.calls.find(
      (call) =>
        call[0] === STATE_UPDATE &&
        (call[1] as StatePayload)?.started === false &&
        (call[1] as StatePayload)?.players.length === 2
    );
    expect(stateUpdateCallPlayer2).toBeDefined();
    if (stateUpdateCallPlayer2)
      expect((stateUpdateCallPlayer2[1] as StatePayload).players.length).toBe(2);
    topLevelEmitMock.mockClear();
    globalMockSocket.emit.mockClear();

    // Check if gameState.started is false before trying to start the game
    expect(gameController['gameState'].started).toBe(false);

    globalMockSocket.id = 'socket-A';
    // Call the controller's startGame logic directly instead of simulating the event
    (gameController['handleStartGame'] as Function)({ computerCount: 0, socket: globalMockSocket });

    // After starting, the gameState.deck should be initialized with cards
    expect(gameController['gameState'].deck).not.toBeNull();
    expect(gameController['gameState'].deck!.length).toBe(52 - 2 * 9);
    const playerA_Instance = Array.from(gameController['players'].values()).find(
      (p) => p.name === playerAJoin.playerName
    );
    const playerB_Instance = Array.from(gameController['players'].values()).find(
      (p) => p.name === playerBJoin.playerName
    );
    expect(playerA_Instance && playerA_Instance.hand.length).toBe(3);
    expect(playerB_Instance && playerB_Instance.hand.length).toBe(3);

    const stateUpdateCallStart = topLevelEmitMock.mock.calls.find(
      (call) => call[0] === STATE_UPDATE && (call[1] as StatePayload)?.started === true
    );
    expect(stateUpdateCallStart).toBeDefined();
    if (stateUpdateCallStart) {
      expect((stateUpdateCallStart[1] as StatePayload).players.length).toBe(2);
      // The first player is the human who joined first
      expect(
        (stateUpdateCallStart[1] as StatePayload).players.some(
          (p: any) => p.name === playerAJoin.playerName
        )
      ).toBe(true);
    }

    const nextTurnCall = topLevelEmitMock.mock.calls.find((call) => call[0] === NEXT_TURN);
    expect(nextTurnCall).toBeDefined();
    // The first player to act is the first human
    if (nextTurnCall && playerA_Instance) expect(nextTurnCall[1]).toBe(playerA_Instance.id);
  });
});

// Custom GameState for maxPlayers test
class TestGameState extends GameState {
  constructor() {
    super();
    Object.defineProperty(this, 'maxPlayers', { value: 2 });
  }
}

describe('Comprehensive Join/Lobby/Start Flow Edge Cases', () => {
  let gameController: GameController;
  let socketA: MockSocket;
  let socketB: MockSocket;
  let socketC: MockSocket;

  beforeEach(() => {
    topLevelEmitMock.mockClear();
    socketA = {
      id: 'socket-A',
      join: jest.fn(),
      emit: jest.fn((event: string, payload?: any) => topLevelEmitMock(event, payload)),
      on: jest.fn(),
      removeAllListeners: jest.fn(),
      eventHandlers: {},
      simulateIncomingEvent: () => {},
      disconnect: jest.fn(),
    };
    socketB = { ...socketA, id: 'socket-B' };
    socketC = { ...socketA, id: 'socket-C' };
    // Patch emit method again in case server mutates socket objects
    [socketA, socketB, socketC].forEach((s) => {
      s.emit = jest.fn((event: string, payload?: any) => topLevelEmitMock(event, payload));
    });
    mockIo.sockets.sockets.clear();
    mockIo.sockets.sockets.set(socketA.id, socketA);
    mockIo.sockets.sockets.set(socketB.id, socketB);
    mockIo.sockets.sockets.set(socketC.id, socketC);
    // Ensure all sockets in the map have their emit patched
    for (const sock of mockIo.sockets.sockets.values()) {
      sock.emit = jest.fn((event: string, payload?: any) => topLevelEmitMock(event, payload));
    }
    // Debug: log all socket ids and their emit function type
    // console.log('SOCKETS IN MAP:', Array.from(mockIo.sockets.sockets.entries()).map(([id, s]) => ({ id, emitType: typeof s.emit })));
    gameController = new GameController(mockIo as any, 'test-room');
  });

  test('Prevents duplicate join with same socket/player ID', () => {
    const joinPayload: JoinGamePayload = {
      id: socketA.id,
      playerName: 'Alpha',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayload);
    // Try to join again with same socket
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayload);
    // Debug: print all emit calls
    console.log('EMIT CALLS:', JSON.stringify(topLevelEmitMock.mock.calls, null, 2));
    // Should emit error event for duplicate
    const errorCall = topLevelEmitMock.mock.calls.find((call) => call[0] === ERROR_EVENT);
    expect(errorCall).toBeDefined();
    // Only one player in the list
    expect(Array.from(gameController['players'].values()).length).toBe(1);
  });

  test('Join with missing/invalid playerName falls back to default', () => {
    const joinPayload: any = { numHumans: 1, numCPUs: 0, roomId: 'test-room' };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayload);
    const player = Array.from(gameController['players'].values())[0];
    expect(player.name).toMatch(/^Player-/);
  });

  test('Join with whitespace/empty playerName falls back to default', () => {
    const joinPayload: any = { playerName: '   ', numHumans: 1, numCPUs: 0, roomId: 'test-room' };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayload);
    const player = Array.from(gameController['players'].values())[0];
    expect(player.name).toMatch(/^Player-/);
  });

  test('Rejoin logic restores player state', () => {
    const joinPayload: JoinGamePayload = {
      playerName: 'Bravo',
      numHumans: 1,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayload);
    // Simulate disconnect
    const playerId = Array.from(gameController['players'].keys())[0];
    gameController['players'].get(playerId)!.disconnected = true;
    // Rejoin
    (gameController['publicHandleRejoin'] as Function)(socketA, 'test-room', playerId);
    expect(gameController['players'].get(playerId)!.disconnected).toBe(false);
    expect(topLevelEmitMock).toHaveBeenCalledWith(
      JOINED,
      expect.objectContaining({ id: playerId })
    );
  });

  test('Host reassignment when host disconnects before game start', () => {
    const joinPayloadA: JoinGamePayload = {
      playerName: 'Host',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    const joinPayloadB: JoinGamePayload = {
      playerName: 'Guest',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayloadA);
    (gameController['publicHandleJoin'] as Function)(socketB, joinPayloadB);
    // Simulate host disconnect
    const hostId = Array.from(gameController['players'].keys())[0];
    gameController['players'].get(hostId)!.disconnected = true;
    // Reassign host
    gameController['hostId'] = Array.from(gameController['players'].keys())[1];
    expect(gameController['players'].get(gameController['hostId'])!.status).toBe('joined');
    // Optionally, update status to 'host' in your logic
  });

  test('Prevents join when room is full', () => {
    // Use custom GameState with maxPlayers = 2
    gameController['gameState'] = new TestGameState() as any;
    const joinPayloadA: JoinGamePayload = {
      id: socketA.id,
      playerName: 'A',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    const joinPayloadB: JoinGamePayload = {
      id: socketB.id,
      playerName: 'B',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    const joinPayloadC: JoinGamePayload = {
      id: socketC.id,
      playerName: 'C',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayloadA);
    (gameController['publicHandleJoin'] as Function)(socketB, joinPayloadB);
    (gameController['publicHandleJoin'] as Function)(socketC, joinPayloadC);
    // Should emit error for third join
    const errorCall = topLevelEmitMock.mock.calls.find((call) => call[0] === ERROR_EVENT);
    expect(errorCall).toBeDefined();
    expect(Array.from(gameController['players'].values()).length).toBe(2);
  });

  test('Prevents join after game has started', () => {
    const joinPayloadA: JoinGamePayload = {
      id: socketA.id,
      playerName: 'A',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayloadA);
    // Start game
    (gameController['handleStartGame'] as Function)({ computerCount: 0, socket: socketA });
    // Try to join after start
    const joinPayloadB: JoinGamePayload = {
      id: socketB.id,
      playerName: 'B',
      numHumans: 2,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketB, joinPayloadB);
    const errorCall = topLevelEmitMock.mock.calls.find((call) => call[0] === ERROR_EVENT);
    expect(errorCall).toBeDefined();
    expect(Array.from(gameController['players'].values()).length).toBe(1);
  });

  test('CPUs only added by host, not by regular joiners', () => {
    const joinPayloadA: JoinGamePayload = {
      playerName: 'Host',
      numHumans: 2,
      numCPUs: 2,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayloadA);
    // Only host triggers CPU add on start
    (gameController['handleStartGame'] as Function)({ computerCount: 2, socket: socketA });
    expect(gameController['players'].has('COMPUTER_1')).toBe(true);
    expect(gameController['players'].has('COMPUTER_2')).toBe(true);
    // Regular joiner can't add CPUs
    const joinPayloadB: JoinGamePayload = {
      playerName: 'Guest',
      numHumans: 2,
      numCPUs: 2,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketB, joinPayloadB);
    expect(gameController['players'].size).toBeLessThanOrEqual(4);
  });

  test('Player list is consistent after each join', () => {
    const joinPayloadA: JoinGamePayload = {
      playerName: 'A',
      numHumans: 3,
      numCPUs: 0,
      roomId: 'test-room',
    };
    const joinPayloadB: JoinGamePayload = {
      playerName: 'B',
      numHumans: 3,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayloadA);
    expect(Array.from(gameController['players'].values()).map((p) => p.name)).toContain('A');
    (gameController['publicHandleJoin'] as Function)(socketB, joinPayloadB);
    expect(Array.from(gameController['players'].values()).map((p) => p.name)).toEqual(
      expect.arrayContaining(['A', 'B'])
    );
  });

  test('Session persistence: player leaves and rejoins with state', () => {
    const joinPayload: JoinGamePayload = {
      playerName: 'Persist',
      numHumans: 1,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayload);
    const playerId = Array.from(gameController['players'].keys())[0];
    // Simulate player leaves
    gameController['players'].get(playerId)!.disconnected = true;
    // Rejoin
    (gameController['publicHandleRejoin'] as Function)(socketA, 'test-room', playerId);
    expect(gameController['players'].get(playerId)!.disconnected).toBe(false);
  });

  test('All relevant events are emitted with correct payloads', () => {
    const joinPayload: JoinGamePayload = {
      playerName: 'Eventful',
      numHumans: 1,
      numCPUs: 0,
      roomId: 'test-room',
    };
    (gameController['publicHandleJoin'] as Function)(socketA, joinPayload);
    (gameController['handleStartGame'] as Function)({ computerCount: 0, socket: socketA });
    // Check for JOINED, LOBBY, STATE_UPDATE
    expect(topLevelEmitMock).toHaveBeenCalledWith(JOINED, expect.any(Object));
    expect(topLevelEmitMock).toHaveBeenCalledWith(LOBBY, expect.any(Object));
    expect(topLevelEmitMock).toHaveBeenCalledWith(STATE_UPDATE, expect.any(Object));
    // If not enough players, expect ERROR_EVENT instead of NEXT_TURN
    if (gameController['gameState'].players.length < 2) {
      const errorCall = topLevelEmitMock.mock.calls.find((call) => call[0] === ERROR_EVENT);
      expect(errorCall).toBeDefined();
    } else {
      expect(topLevelEmitMock).toHaveBeenCalledWith(NEXT_TURN, expect.anything());
    }
  });
});
